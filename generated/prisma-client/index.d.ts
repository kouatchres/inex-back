// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  candidate: (where?: CandidateWhereInput) => Promise<boolean>;
  division: (where?: DivisionWhereInput) => Promise<boolean>;
  exam: (where?: ExamWhereInput) => Promise<boolean>;
  examSession: (where?: ExamSessionWhereInput) => Promise<boolean>;
  gender: (where?: GenderWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  presence: (where?: PresenceWhereInput) => Promise<boolean>;
  region: (where?: RegionWhereInput) => Promise<boolean>;
  series: (where?: SeriesWhereInput) => Promise<boolean>;
  subDivision: (where?: SubDivisionWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  town: (where?: TownWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  examCenter: (where?: examCenterWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  candidate: (where: CandidateWhereUniqueInput) => CandidateNullablePromise;
  candidates: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Candidate>;
  candidatesConnection: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CandidateConnectionPromise;
  division: (where: DivisionWhereUniqueInput) => DivisionNullablePromise;
  divisions: (args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Division>;
  divisionsConnection: (args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DivisionConnectionPromise;
  exam: (where: ExamWhereUniqueInput) => ExamNullablePromise;
  exams: (args?: {
    where?: ExamWhereInput;
    orderBy?: ExamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Exam>;
  examsConnection: (args?: {
    where?: ExamWhereInput;
    orderBy?: ExamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExamConnectionPromise;
  examSession: (
    where: ExamSessionWhereUniqueInput
  ) => ExamSessionNullablePromise;
  examSessions: (args?: {
    where?: ExamSessionWhereInput;
    orderBy?: ExamSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExamSession>;
  examSessionsConnection: (args?: {
    where?: ExamSessionWhereInput;
    orderBy?: ExamSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExamSessionConnectionPromise;
  gender: (where: GenderWhereUniqueInput) => GenderNullablePromise;
  genders: (args?: {
    where?: GenderWhereInput;
    orderBy?: GenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Gender>;
  gendersConnection: (args?: {
    where?: GenderWhereInput;
    orderBy?: GenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GenderConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  presence: (where: PresenceWhereUniqueInput) => PresenceNullablePromise;
  presences: (args?: {
    where?: PresenceWhereInput;
    orderBy?: PresenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Presence>;
  presencesConnection: (args?: {
    where?: PresenceWhereInput;
    orderBy?: PresenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PresenceConnectionPromise;
  region: (where: RegionWhereUniqueInput) => RegionNullablePromise;
  regions: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Region>;
  regionsConnection: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegionConnectionPromise;
  series: (where: SeriesWhereUniqueInput) => SeriesNullablePromise;
  serieses: (args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Series>;
  seriesesConnection: (args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SeriesConnectionPromise;
  subDivision: (
    where: SubDivisionWhereUniqueInput
  ) => SubDivisionNullablePromise;
  subDivisions: (args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubDivision>;
  subDivisionsConnection: (args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubDivisionConnectionPromise;
  subject: (where: SubjectWhereUniqueInput) => SubjectNullablePromise;
  subjects: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Subject>;
  subjectsConnection: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectConnectionPromise;
  town: (where: TownWhereUniqueInput) => TownNullablePromise;
  towns: (args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Town>;
  townsConnection: (args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TownConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  examCenter: (where: examCenterWhereUniqueInput) => examCenterNullablePromise;
  examCenters: (args?: {
    where?: examCenterWhereInput;
    orderBy?: examCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<examCenter>;
  examCentersConnection: (args?: {
    where?: examCenterWhereInput;
    orderBy?: examCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => examCenterConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCandidate: (data: CandidateCreateInput) => CandidatePromise;
  updateCandidate: (args: {
    data: CandidateUpdateInput;
    where: CandidateWhereUniqueInput;
  }) => CandidatePromise;
  updateManyCandidates: (args: {
    data: CandidateUpdateManyMutationInput;
    where?: CandidateWhereInput;
  }) => BatchPayloadPromise;
  upsertCandidate: (args: {
    where: CandidateWhereUniqueInput;
    create: CandidateCreateInput;
    update: CandidateUpdateInput;
  }) => CandidatePromise;
  deleteCandidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  deleteManyCandidates: (where?: CandidateWhereInput) => BatchPayloadPromise;
  createDivision: (data: DivisionCreateInput) => DivisionPromise;
  updateDivision: (args: {
    data: DivisionUpdateInput;
    where: DivisionWhereUniqueInput;
  }) => DivisionPromise;
  updateManyDivisions: (args: {
    data: DivisionUpdateManyMutationInput;
    where?: DivisionWhereInput;
  }) => BatchPayloadPromise;
  upsertDivision: (args: {
    where: DivisionWhereUniqueInput;
    create: DivisionCreateInput;
    update: DivisionUpdateInput;
  }) => DivisionPromise;
  deleteDivision: (where: DivisionWhereUniqueInput) => DivisionPromise;
  deleteManyDivisions: (where?: DivisionWhereInput) => BatchPayloadPromise;
  createExam: (data: ExamCreateInput) => ExamPromise;
  updateExam: (args: {
    data: ExamUpdateInput;
    where: ExamWhereUniqueInput;
  }) => ExamPromise;
  updateManyExams: (args: {
    data: ExamUpdateManyMutationInput;
    where?: ExamWhereInput;
  }) => BatchPayloadPromise;
  upsertExam: (args: {
    where: ExamWhereUniqueInput;
    create: ExamCreateInput;
    update: ExamUpdateInput;
  }) => ExamPromise;
  deleteExam: (where: ExamWhereUniqueInput) => ExamPromise;
  deleteManyExams: (where?: ExamWhereInput) => BatchPayloadPromise;
  createExamSession: (data: ExamSessionCreateInput) => ExamSessionPromise;
  updateExamSession: (args: {
    data: ExamSessionUpdateInput;
    where: ExamSessionWhereUniqueInput;
  }) => ExamSessionPromise;
  updateManyExamSessions: (args: {
    data: ExamSessionUpdateManyMutationInput;
    where?: ExamSessionWhereInput;
  }) => BatchPayloadPromise;
  upsertExamSession: (args: {
    where: ExamSessionWhereUniqueInput;
    create: ExamSessionCreateInput;
    update: ExamSessionUpdateInput;
  }) => ExamSessionPromise;
  deleteExamSession: (where: ExamSessionWhereUniqueInput) => ExamSessionPromise;
  deleteManyExamSessions: (
    where?: ExamSessionWhereInput
  ) => BatchPayloadPromise;
  createGender: (data: GenderCreateInput) => GenderPromise;
  updateGender: (args: {
    data: GenderUpdateInput;
    where: GenderWhereUniqueInput;
  }) => GenderPromise;
  updateManyGenders: (args: {
    data: GenderUpdateManyMutationInput;
    where?: GenderWhereInput;
  }) => BatchPayloadPromise;
  upsertGender: (args: {
    where: GenderWhereUniqueInput;
    create: GenderCreateInput;
    update: GenderUpdateInput;
  }) => GenderPromise;
  deleteGender: (where: GenderWhereUniqueInput) => GenderPromise;
  deleteManyGenders: (where?: GenderWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createPresence: (data: PresenceCreateInput) => PresencePromise;
  updatePresence: (args: {
    data: PresenceUpdateInput;
    where: PresenceWhereUniqueInput;
  }) => PresencePromise;
  updateManyPresences: (args: {
    data: PresenceUpdateManyMutationInput;
    where?: PresenceWhereInput;
  }) => BatchPayloadPromise;
  upsertPresence: (args: {
    where: PresenceWhereUniqueInput;
    create: PresenceCreateInput;
    update: PresenceUpdateInput;
  }) => PresencePromise;
  deletePresence: (where: PresenceWhereUniqueInput) => PresencePromise;
  deleteManyPresences: (where?: PresenceWhereInput) => BatchPayloadPromise;
  createRegion: (data: RegionCreateInput) => RegionPromise;
  updateRegion: (args: {
    data: RegionUpdateInput;
    where: RegionWhereUniqueInput;
  }) => RegionPromise;
  updateManyRegions: (args: {
    data: RegionUpdateManyMutationInput;
    where?: RegionWhereInput;
  }) => BatchPayloadPromise;
  upsertRegion: (args: {
    where: RegionWhereUniqueInput;
    create: RegionCreateInput;
    update: RegionUpdateInput;
  }) => RegionPromise;
  deleteRegion: (where: RegionWhereUniqueInput) => RegionPromise;
  deleteManyRegions: (where?: RegionWhereInput) => BatchPayloadPromise;
  createSeries: (data: SeriesCreateInput) => SeriesPromise;
  updateSeries: (args: {
    data: SeriesUpdateInput;
    where: SeriesWhereUniqueInput;
  }) => SeriesPromise;
  updateManySerieses: (args: {
    data: SeriesUpdateManyMutationInput;
    where?: SeriesWhereInput;
  }) => BatchPayloadPromise;
  upsertSeries: (args: {
    where: SeriesWhereUniqueInput;
    create: SeriesCreateInput;
    update: SeriesUpdateInput;
  }) => SeriesPromise;
  deleteSeries: (where: SeriesWhereUniqueInput) => SeriesPromise;
  deleteManySerieses: (where?: SeriesWhereInput) => BatchPayloadPromise;
  createSubDivision: (data: SubDivisionCreateInput) => SubDivisionPromise;
  updateSubDivision: (args: {
    data: SubDivisionUpdateInput;
    where: SubDivisionWhereUniqueInput;
  }) => SubDivisionPromise;
  updateManySubDivisions: (args: {
    data: SubDivisionUpdateManyMutationInput;
    where?: SubDivisionWhereInput;
  }) => BatchPayloadPromise;
  upsertSubDivision: (args: {
    where: SubDivisionWhereUniqueInput;
    create: SubDivisionCreateInput;
    update: SubDivisionUpdateInput;
  }) => SubDivisionPromise;
  deleteSubDivision: (where: SubDivisionWhereUniqueInput) => SubDivisionPromise;
  deleteManySubDivisions: (
    where?: SubDivisionWhereInput
  ) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateSubject: (args: {
    data: SubjectUpdateInput;
    where: SubjectWhereUniqueInput;
  }) => SubjectPromise;
  updateManySubjects: (args: {
    data: SubjectUpdateManyMutationInput;
    where?: SubjectWhereInput;
  }) => BatchPayloadPromise;
  upsertSubject: (args: {
    where: SubjectWhereUniqueInput;
    create: SubjectCreateInput;
    update: SubjectUpdateInput;
  }) => SubjectPromise;
  deleteSubject: (where: SubjectWhereUniqueInput) => SubjectPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createTown: (data: TownCreateInput) => TownPromise;
  updateTown: (args: {
    data: TownUpdateInput;
    where: TownWhereUniqueInput;
  }) => TownPromise;
  updateManyTowns: (args: {
    data: TownUpdateManyMutationInput;
    where?: TownWhereInput;
  }) => BatchPayloadPromise;
  upsertTown: (args: {
    where: TownWhereUniqueInput;
    create: TownCreateInput;
    update: TownUpdateInput;
  }) => TownPromise;
  deleteTown: (where: TownWhereUniqueInput) => TownPromise;
  deleteManyTowns: (where?: TownWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createexamCenter: (data: examCenterCreateInput) => examCenterPromise;
  updateexamCenter: (args: {
    data: examCenterUpdateInput;
    where: examCenterWhereUniqueInput;
  }) => examCenterPromise;
  updateManyexamCenters: (args: {
    data: examCenterUpdateManyMutationInput;
    where?: examCenterWhereInput;
  }) => BatchPayloadPromise;
  upsertexamCenter: (args: {
    where: examCenterWhereUniqueInput;
    create: examCenterCreateInput;
    update: examCenterUpdateInput;
  }) => examCenterPromise;
  deleteexamCenter: (where: examCenterWhereUniqueInput) => examCenterPromise;
  deleteManyexamCenters: (where?: examCenterWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  candidate: (
    where?: CandidateSubscriptionWhereInput
  ) => CandidateSubscriptionPayloadSubscription;
  division: (
    where?: DivisionSubscriptionWhereInput
  ) => DivisionSubscriptionPayloadSubscription;
  exam: (
    where?: ExamSubscriptionWhereInput
  ) => ExamSubscriptionPayloadSubscription;
  examSession: (
    where?: ExamSessionSubscriptionWhereInput
  ) => ExamSessionSubscriptionPayloadSubscription;
  gender: (
    where?: GenderSubscriptionWhereInput
  ) => GenderSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  presence: (
    where?: PresenceSubscriptionWhereInput
  ) => PresenceSubscriptionPayloadSubscription;
  region: (
    where?: RegionSubscriptionWhereInput
  ) => RegionSubscriptionPayloadSubscription;
  series: (
    where?: SeriesSubscriptionWhereInput
  ) => SeriesSubscriptionPayloadSubscription;
  subDivision: (
    where?: SubDivisionSubscriptionWhereInput
  ) => SubDivisionSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  town: (
    where?: TownSubscriptionWhereInput
  ) => TownSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  examCenter: (
    where?: examCenterSubscriptionWhereInput
  ) => examCenterSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type RegionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "regName_ASC"
  | "regName_DESC"
  | "regCode_ASC"
  | "regCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DivisionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "divName_ASC"
  | "divName_DESC"
  | "divCode_ASC"
  | "divCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PresenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "presenceName_ASC"
  | "presenceName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "descrption_ASC"
  | "descrption_DESC"
  | "image_ASC"
  | "image_DESC"
  | "largeImage_ASC"
  | "largeImage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subjName_ASC"
  | "subjName_DESC"
  | "subjCode_ASC"
  | "subjCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ExamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "examName_ASC"
  | "examName_DESC"
  | "examCode_ASC"
  | "examCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExamSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sessionName_ASC"
  | "sessionName_DESC"
  | "sessionCode_ASC"
  | "sessionCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GenderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "genderName_ASC"
  | "genderName_DESC"
  | "genderCode_ASC"
  | "genderCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CandidateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "cand1stName_ASC"
  | "cand1stName_DESC"
  | "cand2ndName_ASC"
  | "cand2ndName_DESC"
  | "cand3rdName_ASC"
  | "cand3rdName_DESC"
  | "placeOfBirth_ASC"
  | "placeOfBirth_DESC"
  | "candCode_ASC"
  | "candCode_DESC"
  | "image_ASC"
  | "image_DESC"
  | "birthCertNumber_ASC"
  | "birthCertNumber_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phoneNumb_ASC"
  | "phoneNumb_DESC"
  | "dateOfBirth_ASC"
  | "dateOfBirth_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TownOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "townName_ASC"
  | "townName_DESC"
  | "townCode_ASC"
  | "townCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type examCenterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "centerName_ASC"
  | "centerName_DESC"
  | "centerCode_ASC"
  | "centerCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SeriesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "seriesName_ASC"
  | "seriesName_DESC"
  | "seriesCode_ASC"
  | "seriesCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubDivisionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subDivName_ASC"
  | "subDivName_DESC"
  | "subDivCode_ASC"
  | "subDivCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface SeriesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seriesName?: Maybe<String>;
  seriesName_not?: Maybe<String>;
  seriesName_in?: Maybe<String[] | String>;
  seriesName_not_in?: Maybe<String[] | String>;
  seriesName_lt?: Maybe<String>;
  seriesName_lte?: Maybe<String>;
  seriesName_gt?: Maybe<String>;
  seriesName_gte?: Maybe<String>;
  seriesName_contains?: Maybe<String>;
  seriesName_not_contains?: Maybe<String>;
  seriesName_starts_with?: Maybe<String>;
  seriesName_not_starts_with?: Maybe<String>;
  seriesName_ends_with?: Maybe<String>;
  seriesName_not_ends_with?: Maybe<String>;
  seriesCode?: Maybe<String>;
  seriesCode_not?: Maybe<String>;
  seriesCode_in?: Maybe<String[] | String>;
  seriesCode_not_in?: Maybe<String[] | String>;
  seriesCode_lt?: Maybe<String>;
  seriesCode_lte?: Maybe<String>;
  seriesCode_gt?: Maybe<String>;
  seriesCode_gte?: Maybe<String>;
  seriesCode_contains?: Maybe<String>;
  seriesCode_not_contains?: Maybe<String>;
  seriesCode_starts_with?: Maybe<String>;
  seriesCode_not_starts_with?: Maybe<String>;
  seriesCode_ends_with?: Maybe<String>;
  seriesCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
  OR?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
  NOT?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
}

export interface GenderUpdateManyMutationInput {
  genderName?: Maybe<String>;
  genderCode?: Maybe<String>;
}

export interface SubDivisionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubDivisionWhereInput>;
  AND?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
  OR?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
}

export type CandidateWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SeriesUpdateManyMutationInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
}

export interface RegionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  regName?: Maybe<String>;
  regName_not?: Maybe<String>;
  regName_in?: Maybe<String[] | String>;
  regName_not_in?: Maybe<String[] | String>;
  regName_lt?: Maybe<String>;
  regName_lte?: Maybe<String>;
  regName_gt?: Maybe<String>;
  regName_gte?: Maybe<String>;
  regName_contains?: Maybe<String>;
  regName_not_contains?: Maybe<String>;
  regName_starts_with?: Maybe<String>;
  regName_not_starts_with?: Maybe<String>;
  regName_ends_with?: Maybe<String>;
  regName_not_ends_with?: Maybe<String>;
  regCode?: Maybe<String>;
  regCode_not?: Maybe<String>;
  regCode_in?: Maybe<String[] | String>;
  regCode_not_in?: Maybe<String[] | String>;
  regCode_lt?: Maybe<String>;
  regCode_lte?: Maybe<String>;
  regCode_gt?: Maybe<String>;
  regCode_gte?: Maybe<String>;
  regCode_contains?: Maybe<String>;
  regCode_not_contains?: Maybe<String>;
  regCode_starts_with?: Maybe<String>;
  regCode_not_starts_with?: Maybe<String>;
  regCode_ends_with?: Maybe<String>;
  regCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  division_every?: Maybe<DivisionWhereInput>;
  division_some?: Maybe<DivisionWhereInput>;
  division_none?: Maybe<DivisionWhereInput>;
  AND?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  OR?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  NOT?: Maybe<RegionWhereInput[] | RegionWhereInput>;
}

export interface SeriesUpdateInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
}

export interface DivisionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DivisionWhereInput>;
  AND?: Maybe<
    DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput
  >;
  OR?: Maybe<DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput>;
  NOT?: Maybe<
    DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput
  >;
}

export interface SeriesCreateInput {
  id?: Maybe<ID_Input>;
  seriesName: String;
  seriesCode: String;
}

export type ExamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SubjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  examName?: Maybe<String>;
  examName_not?: Maybe<String>;
  examName_in?: Maybe<String[] | String>;
  examName_not_in?: Maybe<String[] | String>;
  examName_lt?: Maybe<String>;
  examName_lte?: Maybe<String>;
  examName_gt?: Maybe<String>;
  examName_gte?: Maybe<String>;
  examName_contains?: Maybe<String>;
  examName_not_contains?: Maybe<String>;
  examName_starts_with?: Maybe<String>;
  examName_not_starts_with?: Maybe<String>;
  examName_ends_with?: Maybe<String>;
  examName_not_ends_with?: Maybe<String>;
  examCode?: Maybe<String>;
  examCode_not?: Maybe<String>;
  examCode_in?: Maybe<String[] | String>;
  examCode_not_in?: Maybe<String[] | String>;
  examCode_lt?: Maybe<String>;
  examCode_lte?: Maybe<String>;
  examCode_gt?: Maybe<String>;
  examCode_gte?: Maybe<String>;
  examCode_contains?: Maybe<String>;
  examCode_not_contains?: Maybe<String>;
  examCode_starts_with?: Maybe<String>;
  examCode_not_starts_with?: Maybe<String>;
  examCode_ends_with?: Maybe<String>;
  examCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExamWhereInput[] | ExamWhereInput>;
  OR?: Maybe<ExamWhereInput[] | ExamWhereInput>;
  NOT?: Maybe<ExamWhereInput[] | ExamWhereInput>;
}

export interface RegionUpdateManyMutationInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
}

export interface examCenterUpdateManyMutationInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
}

export interface SubjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subjName?: Maybe<String>;
  subjName_not?: Maybe<String>;
  subjName_in?: Maybe<String[] | String>;
  subjName_not_in?: Maybe<String[] | String>;
  subjName_lt?: Maybe<String>;
  subjName_lte?: Maybe<String>;
  subjName_gt?: Maybe<String>;
  subjName_gte?: Maybe<String>;
  subjName_contains?: Maybe<String>;
  subjName_not_contains?: Maybe<String>;
  subjName_starts_with?: Maybe<String>;
  subjName_not_starts_with?: Maybe<String>;
  subjName_ends_with?: Maybe<String>;
  subjName_not_ends_with?: Maybe<String>;
  subjCode?: Maybe<String>;
  subjCode_not?: Maybe<String>;
  subjCode_in?: Maybe<String[] | String>;
  subjCode_not_in?: Maybe<String[] | String>;
  subjCode_lt?: Maybe<String>;
  subjCode_lte?: Maybe<String>;
  subjCode_gt?: Maybe<String>;
  subjCode_gte?: Maybe<String>;
  subjCode_contains?: Maybe<String>;
  subjCode_not_contains?: Maybe<String>;
  subjCode_starts_with?: Maybe<String>;
  subjCode_not_starts_with?: Maybe<String>;
  subjCode_ends_with?: Maybe<String>;
  subjCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  OR?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  NOT?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
}

export interface TownUpdateDataInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
  subDiv?: Maybe<SubDivisionUpdateOneRequiredInput>;
}

export interface CandidateWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  cand1stName?: Maybe<String>;
  cand1stName_not?: Maybe<String>;
  cand1stName_in?: Maybe<String[] | String>;
  cand1stName_not_in?: Maybe<String[] | String>;
  cand1stName_lt?: Maybe<String>;
  cand1stName_lte?: Maybe<String>;
  cand1stName_gt?: Maybe<String>;
  cand1stName_gte?: Maybe<String>;
  cand1stName_contains?: Maybe<String>;
  cand1stName_not_contains?: Maybe<String>;
  cand1stName_starts_with?: Maybe<String>;
  cand1stName_not_starts_with?: Maybe<String>;
  cand1stName_ends_with?: Maybe<String>;
  cand1stName_not_ends_with?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand2ndName_not?: Maybe<String>;
  cand2ndName_in?: Maybe<String[] | String>;
  cand2ndName_not_in?: Maybe<String[] | String>;
  cand2ndName_lt?: Maybe<String>;
  cand2ndName_lte?: Maybe<String>;
  cand2ndName_gt?: Maybe<String>;
  cand2ndName_gte?: Maybe<String>;
  cand2ndName_contains?: Maybe<String>;
  cand2ndName_not_contains?: Maybe<String>;
  cand2ndName_starts_with?: Maybe<String>;
  cand2ndName_not_starts_with?: Maybe<String>;
  cand2ndName_ends_with?: Maybe<String>;
  cand2ndName_not_ends_with?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  cand3rdName_not?: Maybe<String>;
  cand3rdName_in?: Maybe<String[] | String>;
  cand3rdName_not_in?: Maybe<String[] | String>;
  cand3rdName_lt?: Maybe<String>;
  cand3rdName_lte?: Maybe<String>;
  cand3rdName_gt?: Maybe<String>;
  cand3rdName_gte?: Maybe<String>;
  cand3rdName_contains?: Maybe<String>;
  cand3rdName_not_contains?: Maybe<String>;
  cand3rdName_starts_with?: Maybe<String>;
  cand3rdName_not_starts_with?: Maybe<String>;
  cand3rdName_ends_with?: Maybe<String>;
  cand3rdName_not_ends_with?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  placeOfBirth_not?: Maybe<String>;
  placeOfBirth_in?: Maybe<String[] | String>;
  placeOfBirth_not_in?: Maybe<String[] | String>;
  placeOfBirth_lt?: Maybe<String>;
  placeOfBirth_lte?: Maybe<String>;
  placeOfBirth_gt?: Maybe<String>;
  placeOfBirth_gte?: Maybe<String>;
  placeOfBirth_contains?: Maybe<String>;
  placeOfBirth_not_contains?: Maybe<String>;
  placeOfBirth_starts_with?: Maybe<String>;
  placeOfBirth_not_starts_with?: Maybe<String>;
  placeOfBirth_ends_with?: Maybe<String>;
  placeOfBirth_not_ends_with?: Maybe<String>;
  candCode?: Maybe<String>;
  candCode_not?: Maybe<String>;
  candCode_in?: Maybe<String[] | String>;
  candCode_not_in?: Maybe<String[] | String>;
  candCode_lt?: Maybe<String>;
  candCode_lte?: Maybe<String>;
  candCode_gt?: Maybe<String>;
  candCode_gte?: Maybe<String>;
  candCode_contains?: Maybe<String>;
  candCode_not_contains?: Maybe<String>;
  candCode_starts_with?: Maybe<String>;
  candCode_not_starts_with?: Maybe<String>;
  candCode_ends_with?: Maybe<String>;
  candCode_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  birthCertNumber_not?: Maybe<String>;
  birthCertNumber_in?: Maybe<String[] | String>;
  birthCertNumber_not_in?: Maybe<String[] | String>;
  birthCertNumber_lt?: Maybe<String>;
  birthCertNumber_lte?: Maybe<String>;
  birthCertNumber_gt?: Maybe<String>;
  birthCertNumber_gte?: Maybe<String>;
  birthCertNumber_contains?: Maybe<String>;
  birthCertNumber_not_contains?: Maybe<String>;
  birthCertNumber_starts_with?: Maybe<String>;
  birthCertNumber_not_starts_with?: Maybe<String>;
  birthCertNumber_ends_with?: Maybe<String>;
  birthCertNumber_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  phoneNumb_not?: Maybe<Int>;
  phoneNumb_in?: Maybe<Int[] | Int>;
  phoneNumb_not_in?: Maybe<Int[] | Int>;
  phoneNumb_lt?: Maybe<Int>;
  phoneNumb_lte?: Maybe<Int>;
  phoneNumb_gt?: Maybe<Int>;
  phoneNumb_gte?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  dateOfBirth_not?: Maybe<DateTimeInput>;
  dateOfBirth_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_lt?: Maybe<DateTimeInput>;
  dateOfBirth_lte?: Maybe<DateTimeInput>;
  dateOfBirth_gt?: Maybe<DateTimeInput>;
  dateOfBirth_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  OR?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  NOT?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
}

export interface TownUpdateOneRequiredInput {
  create?: Maybe<TownCreateInput>;
  update?: Maybe<TownUpdateDataInput>;
  upsert?: Maybe<TownUpsertNestedInput>;
  connect?: Maybe<TownWhereUniqueInput>;
}

export interface DivisionUpdateManyDataInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
}

export interface GenderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GenderWhereInput>;
  AND?: Maybe<GenderSubscriptionWhereInput[] | GenderSubscriptionWhereInput>;
  OR?: Maybe<GenderSubscriptionWhereInput[] | GenderSubscriptionWhereInput>;
  NOT?: Maybe<GenderSubscriptionWhereInput[] | GenderSubscriptionWhereInput>;
}

export interface DivisionUpdateManyWithWhereNestedInput {
  where: DivisionScalarWhereInput;
  data: DivisionUpdateManyDataInput;
}

export interface TownCreateOneInput {
  create?: Maybe<TownCreateInput>;
  connect?: Maybe<TownWhereUniqueInput>;
}

export interface DivisionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  divName?: Maybe<String>;
  divName_not?: Maybe<String>;
  divName_in?: Maybe<String[] | String>;
  divName_not_in?: Maybe<String[] | String>;
  divName_lt?: Maybe<String>;
  divName_lte?: Maybe<String>;
  divName_gt?: Maybe<String>;
  divName_gte?: Maybe<String>;
  divName_contains?: Maybe<String>;
  divName_not_contains?: Maybe<String>;
  divName_starts_with?: Maybe<String>;
  divName_not_starts_with?: Maybe<String>;
  divName_ends_with?: Maybe<String>;
  divName_not_ends_with?: Maybe<String>;
  divCode?: Maybe<String>;
  divCode_not?: Maybe<String>;
  divCode_in?: Maybe<String[] | String>;
  divCode_not_in?: Maybe<String[] | String>;
  divCode_lt?: Maybe<String>;
  divCode_lte?: Maybe<String>;
  divCode_gt?: Maybe<String>;
  divCode_gte?: Maybe<String>;
  divCode_contains?: Maybe<String>;
  divCode_not_contains?: Maybe<String>;
  divCode_starts_with?: Maybe<String>;
  divCode_not_starts_with?: Maybe<String>;
  divCode_ends_with?: Maybe<String>;
  divCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
  OR?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
  NOT?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
}

export type GenderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TownWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GenderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  genderName?: Maybe<String>;
  genderName_not?: Maybe<String>;
  genderName_in?: Maybe<String[] | String>;
  genderName_not_in?: Maybe<String[] | String>;
  genderName_lt?: Maybe<String>;
  genderName_lte?: Maybe<String>;
  genderName_gt?: Maybe<String>;
  genderName_gte?: Maybe<String>;
  genderName_contains?: Maybe<String>;
  genderName_not_contains?: Maybe<String>;
  genderName_starts_with?: Maybe<String>;
  genderName_not_starts_with?: Maybe<String>;
  genderName_ends_with?: Maybe<String>;
  genderName_not_ends_with?: Maybe<String>;
  genderCode?: Maybe<String>;
  genderCode_not?: Maybe<String>;
  genderCode_in?: Maybe<String[] | String>;
  genderCode_not_in?: Maybe<String[] | String>;
  genderCode_lt?: Maybe<String>;
  genderCode_lte?: Maybe<String>;
  genderCode_gt?: Maybe<String>;
  genderCode_gte?: Maybe<String>;
  genderCode_contains?: Maybe<String>;
  genderCode_not_contains?: Maybe<String>;
  genderCode_starts_with?: Maybe<String>;
  genderCode_not_starts_with?: Maybe<String>;
  genderCode_ends_with?: Maybe<String>;
  genderCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GenderWhereInput[] | GenderWhereInput>;
  OR?: Maybe<GenderWhereInput[] | GenderWhereInput>;
  NOT?: Maybe<GenderWhereInput[] | GenderWhereInput>;
}

export interface DivisionUpsertWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput;
  update: DivisionUpdateWithoutRegionDataInput;
  create: DivisionCreateWithoutRegionInput;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface TownWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  townName?: Maybe<String>;
  townName_not?: Maybe<String>;
  townName_in?: Maybe<String[] | String>;
  townName_not_in?: Maybe<String[] | String>;
  townName_lt?: Maybe<String>;
  townName_lte?: Maybe<String>;
  townName_gt?: Maybe<String>;
  townName_gte?: Maybe<String>;
  townName_contains?: Maybe<String>;
  townName_not_contains?: Maybe<String>;
  townName_starts_with?: Maybe<String>;
  townName_not_starts_with?: Maybe<String>;
  townName_ends_with?: Maybe<String>;
  townName_not_ends_with?: Maybe<String>;
  townCode?: Maybe<String>;
  townCode_not?: Maybe<String>;
  townCode_in?: Maybe<String[] | String>;
  townCode_not_in?: Maybe<String[] | String>;
  townCode_lt?: Maybe<String>;
  townCode_lte?: Maybe<String>;
  townCode_gt?: Maybe<String>;
  townCode_gte?: Maybe<String>;
  townCode_contains?: Maybe<String>;
  townCode_not_contains?: Maybe<String>;
  townCode_starts_with?: Maybe<String>;
  townCode_not_starts_with?: Maybe<String>;
  townCode_ends_with?: Maybe<String>;
  townCode_not_ends_with?: Maybe<String>;
  subDiv?: Maybe<SubDivisionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TownWhereInput[] | TownWhereInput>;
  OR?: Maybe<TownWhereInput[] | TownWhereInput>;
  NOT?: Maybe<TownWhereInput[] | TownWhereInput>;
}

export interface TownUpdateManyMutationInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubjectWhereInput>;
  AND?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  OR?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  NOT?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
}

export interface SubDivisionUpsertNestedInput {
  update: SubDivisionUpdateDataInput;
  create: SubDivisionCreateInput;
}

export interface DivisionUpdateWithoutRegionDataInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface DivisionUpdateWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput;
  data: DivisionUpdateWithoutRegionDataInput;
}

export interface SubDivisionUpdateOneRequiredInput {
  create?: Maybe<SubDivisionCreateInput>;
  update?: Maybe<SubDivisionUpdateDataInput>;
  upsert?: Maybe<SubDivisionUpsertNestedInput>;
  connect?: Maybe<SubDivisionWhereUniqueInput>;
}

export interface DivisionUpdateManyWithoutRegionInput {
  create?: Maybe<
    DivisionCreateWithoutRegionInput[] | DivisionCreateWithoutRegionInput
  >;
  delete?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  connect?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  set?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  disconnect?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  update?: Maybe<
    | DivisionUpdateWithWhereUniqueWithoutRegionInput[]
    | DivisionUpdateWithWhereUniqueWithoutRegionInput
  >;
  upsert?: Maybe<
    | DivisionUpsertWithWhereUniqueWithoutRegionInput[]
    | DivisionUpsertWithWhereUniqueWithoutRegionInput
  >;
  deleteMany?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
  updateMany?: Maybe<
    | DivisionUpdateManyWithWhereNestedInput[]
    | DivisionUpdateManyWithWhereNestedInput
  >;
}

export type PresenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PresenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  presenceName?: Maybe<Boolean>;
  presenceName_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
  OR?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
  NOT?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
}

export interface RegionUpdateInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateManyWithoutRegionInput>;
}

export interface TownCreateInput {
  id?: Maybe<ID_Input>;
  townName: String;
  townCode: String;
  subDiv: SubDivisionCreateOneInput;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface SubjectUpdateInput {
  subjName?: Maybe<String>;
  subjCode?: Maybe<String>;
}

export interface TownSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TownWhereInput>;
  AND?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
  OR?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
  NOT?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
}

export interface RegionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegionWhereInput>;
  AND?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  OR?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  NOT?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
}

export interface DivisionCreateWithoutRegionInput {
  id?: Maybe<ID_Input>;
  divName: String;
  divCode: String;
}

export interface SubDivisionUpdateManyMutationInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
}

export interface DivisionCreateManyWithoutRegionInput {
  create?: Maybe<
    DivisionCreateWithoutRegionInput[] | DivisionCreateWithoutRegionInput
  >;
  connect?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
}

export type SeriesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RegionCreateInput {
  id?: Maybe<ID_Input>;
  regName: String;
  regCode: String;
  division?: Maybe<DivisionCreateManyWithoutRegionInput>;
}

export interface examCenterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<examCenterWhereInput>;
  AND?: Maybe<
    examCenterSubscriptionWhereInput[] | examCenterSubscriptionWhereInput
  >;
  OR?: Maybe<
    examCenterSubscriptionWhereInput[] | examCenterSubscriptionWhereInput
  >;
  NOT?: Maybe<
    examCenterSubscriptionWhereInput[] | examCenterSubscriptionWhereInput
  >;
}

export type examCenterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DivisionUpdateOneRequiredInput {
  create?: Maybe<DivisionCreateInput>;
  update?: Maybe<DivisionUpdateDataInput>;
  upsert?: Maybe<DivisionUpsertNestedInput>;
  connect?: Maybe<DivisionWhereUniqueInput>;
}

export interface PresenceUpdateManyMutationInput {
  presenceName?: Maybe<Boolean>;
}

export interface DivisionCreateOneInput {
  create?: Maybe<DivisionCreateInput>;
  connect?: Maybe<DivisionWhereUniqueInput>;
}

export interface examCenterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  centerName?: Maybe<String>;
  centerName_not?: Maybe<String>;
  centerName_in?: Maybe<String[] | String>;
  centerName_not_in?: Maybe<String[] | String>;
  centerName_lt?: Maybe<String>;
  centerName_lte?: Maybe<String>;
  centerName_gt?: Maybe<String>;
  centerName_gte?: Maybe<String>;
  centerName_contains?: Maybe<String>;
  centerName_not_contains?: Maybe<String>;
  centerName_starts_with?: Maybe<String>;
  centerName_not_starts_with?: Maybe<String>;
  centerName_ends_with?: Maybe<String>;
  centerName_not_ends_with?: Maybe<String>;
  centerCode?: Maybe<String>;
  centerCode_not?: Maybe<String>;
  centerCode_in?: Maybe<String[] | String>;
  centerCode_not_in?: Maybe<String[] | String>;
  centerCode_lt?: Maybe<String>;
  centerCode_lte?: Maybe<String>;
  centerCode_gt?: Maybe<String>;
  centerCode_gte?: Maybe<String>;
  centerCode_contains?: Maybe<String>;
  centerCode_not_contains?: Maybe<String>;
  centerCode_starts_with?: Maybe<String>;
  centerCode_not_starts_with?: Maybe<String>;
  centerCode_ends_with?: Maybe<String>;
  centerCode_not_ends_with?: Maybe<String>;
  town?: Maybe<TownWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<examCenterWhereInput[] | examCenterWhereInput>;
  OR?: Maybe<examCenterWhereInput[] | examCenterWhereInput>;
  NOT?: Maybe<examCenterWhereInput[] | examCenterWhereInput>;
}

export interface SubDivisionCreateInput {
  id?: Maybe<ID_Input>;
  subDivName: String;
  subDivCode: String;
  division: DivisionCreateOneInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ExamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExamWhereInput>;
  AND?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
  OR?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
  NOT?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
}

export interface PresenceUpdateInput {
  presenceName?: Maybe<Boolean>;
}

export interface CandidateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CandidateWhereInput>;
  AND?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  OR?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
}

export interface PresenceCreateInput {
  id?: Maybe<ID_Input>;
  presenceName: Boolean;
}

export interface TownUpsertNestedInput {
  update: TownUpdateDataInput;
  create: TownCreateInput;
}

export interface ItemUpdateManyMutationInput {
  title?: Maybe<String>;
  descrption?: Maybe<String>;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
}

export interface ExamSessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sessionName?: Maybe<String>;
  sessionName_not?: Maybe<String>;
  sessionName_in?: Maybe<String[] | String>;
  sessionName_not_in?: Maybe<String[] | String>;
  sessionName_lt?: Maybe<String>;
  sessionName_lte?: Maybe<String>;
  sessionName_gt?: Maybe<String>;
  sessionName_gte?: Maybe<String>;
  sessionName_contains?: Maybe<String>;
  sessionName_not_contains?: Maybe<String>;
  sessionName_starts_with?: Maybe<String>;
  sessionName_not_starts_with?: Maybe<String>;
  sessionName_ends_with?: Maybe<String>;
  sessionName_not_ends_with?: Maybe<String>;
  sessionCode?: Maybe<String>;
  sessionCode_not?: Maybe<String>;
  sessionCode_in?: Maybe<String[] | String>;
  sessionCode_not_in?: Maybe<String[] | String>;
  sessionCode_lt?: Maybe<String>;
  sessionCode_lte?: Maybe<String>;
  sessionCode_gt?: Maybe<String>;
  sessionCode_gte?: Maybe<String>;
  sessionCode_contains?: Maybe<String>;
  sessionCode_not_contains?: Maybe<String>;
  sessionCode_starts_with?: Maybe<String>;
  sessionCode_not_starts_with?: Maybe<String>;
  sessionCode_ends_with?: Maybe<String>;
  sessionCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExamSessionWhereInput[] | ExamSessionWhereInput>;
  OR?: Maybe<ExamSessionWhereInput[] | ExamSessionWhereInput>;
  NOT?: Maybe<ExamSessionWhereInput[] | ExamSessionWhereInput>;
}

export interface examCenterCreateInput {
  id?: Maybe<ID_Input>;
  centerName: String;
  centerCode: String;
  town: TownCreateOneInput;
}

export type DivisionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CandidateCreateInput {
  id?: Maybe<ID_Input>;
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CandidateUpdateInput {
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
}

export interface SubDivisionUpdateDataInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateOneRequiredInput>;
}

export interface CandidateUpdateManyMutationInput {
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
}

export interface SubDivisionCreateOneInput {
  create?: Maybe<SubDivisionCreateInput>;
  connect?: Maybe<SubDivisionWhereUniqueInput>;
}

export interface ItemUpdateInput {
  title?: Maybe<String>;
  descrption?: Maybe<String>;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
}

export interface SubjectUpdateManyMutationInput {
  subjName?: Maybe<String>;
  subjCode?: Maybe<String>;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  descrption: String;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
}

export interface SubjectCreateInput {
  id?: Maybe<ID_Input>;
  subjName: String;
  subjCode: String;
}

export interface DivisionCreateInput {
  id?: Maybe<ID_Input>;
  divName: String;
  divCode: String;
  region: RegionCreateOneWithoutDivisionInput;
}

export interface DivisionUpdateDataInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
  region?: Maybe<RegionUpdateOneRequiredWithoutDivisionInput>;
}

export interface RegionCreateOneWithoutDivisionInput {
  create?: Maybe<RegionCreateWithoutDivisionInput>;
  connect?: Maybe<RegionWhereUniqueInput>;
}

export interface SubDivisionUpdateInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateOneRequiredInput>;
}

export interface RegionCreateWithoutDivisionInput {
  id?: Maybe<ID_Input>;
  regName: String;
  regCode: String;
}

export interface SubDivisionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subDivName?: Maybe<String>;
  subDivName_not?: Maybe<String>;
  subDivName_in?: Maybe<String[] | String>;
  subDivName_not_in?: Maybe<String[] | String>;
  subDivName_lt?: Maybe<String>;
  subDivName_lte?: Maybe<String>;
  subDivName_gt?: Maybe<String>;
  subDivName_gte?: Maybe<String>;
  subDivName_contains?: Maybe<String>;
  subDivName_not_contains?: Maybe<String>;
  subDivName_starts_with?: Maybe<String>;
  subDivName_not_starts_with?: Maybe<String>;
  subDivName_ends_with?: Maybe<String>;
  subDivName_not_ends_with?: Maybe<String>;
  subDivCode?: Maybe<String>;
  subDivCode_not?: Maybe<String>;
  subDivCode_in?: Maybe<String[] | String>;
  subDivCode_not_in?: Maybe<String[] | String>;
  subDivCode_lt?: Maybe<String>;
  subDivCode_lte?: Maybe<String>;
  subDivCode_gt?: Maybe<String>;
  subDivCode_gte?: Maybe<String>;
  subDivCode_contains?: Maybe<String>;
  subDivCode_not_contains?: Maybe<String>;
  subDivCode_starts_with?: Maybe<String>;
  subDivCode_not_starts_with?: Maybe<String>;
  subDivCode_ends_with?: Maybe<String>;
  subDivCode_not_ends_with?: Maybe<String>;
  division?: Maybe<DivisionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
  OR?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
  NOT?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
}

export interface DivisionUpdateInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
  region?: Maybe<RegionUpdateOneRequiredWithoutDivisionInput>;
}

export interface ExamSessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExamSessionWhereInput>;
  AND?: Maybe<
    ExamSessionSubscriptionWhereInput[] | ExamSessionSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExamSessionSubscriptionWhereInput[] | ExamSessionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExamSessionSubscriptionWhereInput[] | ExamSessionSubscriptionWhereInput
  >;
}

export interface RegionUpdateOneRequiredWithoutDivisionInput {
  create?: Maybe<RegionCreateWithoutDivisionInput>;
  update?: Maybe<RegionUpdateWithoutDivisionDataInput>;
  upsert?: Maybe<RegionUpsertWithoutDivisionInput>;
  connect?: Maybe<RegionWhereUniqueInput>;
}

export interface examCenterUpdateInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  town?: Maybe<TownUpdateOneRequiredInput>;
}

export interface RegionUpdateWithoutDivisionDataInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
}

export interface RegionUpsertWithoutDivisionInput {
  update: RegionUpdateWithoutDivisionDataInput;
  create: RegionCreateWithoutDivisionInput;
}

export interface TownUpdateInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
  subDiv?: Maybe<SubDivisionUpdateOneRequiredInput>;
}

export interface DivisionUpdateManyMutationInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
}

export type RegionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExamCreateInput {
  id?: Maybe<ID_Input>;
  examName: String;
  examCode: String;
}

export interface SeriesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SeriesWhereInput>;
  AND?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
  OR?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
  NOT?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
}

export interface ExamUpdateInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
}

export interface DivisionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  divName?: Maybe<String>;
  divName_not?: Maybe<String>;
  divName_in?: Maybe<String[] | String>;
  divName_not_in?: Maybe<String[] | String>;
  divName_lt?: Maybe<String>;
  divName_lte?: Maybe<String>;
  divName_gt?: Maybe<String>;
  divName_gte?: Maybe<String>;
  divName_contains?: Maybe<String>;
  divName_not_contains?: Maybe<String>;
  divName_starts_with?: Maybe<String>;
  divName_not_starts_with?: Maybe<String>;
  divName_ends_with?: Maybe<String>;
  divName_not_ends_with?: Maybe<String>;
  divCode?: Maybe<String>;
  divCode_not?: Maybe<String>;
  divCode_in?: Maybe<String[] | String>;
  divCode_not_in?: Maybe<String[] | String>;
  divCode_lt?: Maybe<String>;
  divCode_lte?: Maybe<String>;
  divCode_gt?: Maybe<String>;
  divCode_gte?: Maybe<String>;
  divCode_contains?: Maybe<String>;
  divCode_not_contains?: Maybe<String>;
  divCode_starts_with?: Maybe<String>;
  divCode_not_starts_with?: Maybe<String>;
  divCode_ends_with?: Maybe<String>;
  divCode_not_ends_with?: Maybe<String>;
  region?: Maybe<RegionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
  OR?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
  NOT?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
}

export interface ExamUpdateManyMutationInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface ExamSessionCreateInput {
  id?: Maybe<ID_Input>;
  sessionName: String;
  sessionCode: String;
}

export interface PresenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PresenceWhereInput>;
  AND?: Maybe<
    PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput
  >;
  OR?: Maybe<PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput>;
  NOT?: Maybe<
    PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput
  >;
}

export interface GenderUpdateInput {
  genderName?: Maybe<String>;
  genderCode?: Maybe<String>;
}

export interface GenderCreateInput {
  id?: Maybe<ID_Input>;
  genderName: String;
  genderCode: String;
}

export interface ExamSessionUpdateManyMutationInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
}

export interface ExamSessionUpdateInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
}

export interface DivisionUpsertNestedInput {
  update: DivisionUpdateDataInput;
  create: DivisionCreateInput;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  descrption?: Maybe<String>;
  descrption_not?: Maybe<String>;
  descrption_in?: Maybe<String[] | String>;
  descrption_not_in?: Maybe<String[] | String>;
  descrption_lt?: Maybe<String>;
  descrption_lte?: Maybe<String>;
  descrption_gt?: Maybe<String>;
  descrption_gte?: Maybe<String>;
  descrption_contains?: Maybe<String>;
  descrption_not_contains?: Maybe<String>;
  descrption_starts_with?: Maybe<String>;
  descrption_not_starts_with?: Maybe<String>;
  descrption_ends_with?: Maybe<String>;
  descrption_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  largeImage?: Maybe<String>;
  largeImage_not?: Maybe<String>;
  largeImage_in?: Maybe<String[] | String>;
  largeImage_not_in?: Maybe<String[] | String>;
  largeImage_lt?: Maybe<String>;
  largeImage_lte?: Maybe<String>;
  largeImage_gt?: Maybe<String>;
  largeImage_gte?: Maybe<String>;
  largeImage_contains?: Maybe<String>;
  largeImage_not_contains?: Maybe<String>;
  largeImage_starts_with?: Maybe<String>;
  largeImage_not_starts_with?: Maybe<String>;
  largeImage_ends_with?: Maybe<String>;
  largeImage_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export type ExamSessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SubDivisionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface examCenterPreviousValues {
  id: ID_Output;
  centerName: String;
  centerCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface examCenterPreviousValuesPromise
  extends Promise<examCenterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface examCenterPreviousValuesSubscription
  extends Promise<AsyncIterator<examCenterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  centerName: () => Promise<AsyncIterator<String>>;
  centerCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamSessionConnection {
  pageInfo: PageInfo;
  edges: ExamSessionEdge[];
}

export interface ExamSessionConnectionPromise
  extends Promise<ExamSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExamSessionEdge>>() => T;
  aggregate: <T = AggregateExamSessionPromise>() => T;
}

export interface ExamSessionConnectionSubscription
  extends Promise<AsyncIterator<ExamSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExamSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExamSessionSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ExamSession {
  id: ID_Output;
  sessionName: String;
  sessionCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamSessionPromise extends Promise<ExamSession>, Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamSessionSubscription
  extends Promise<AsyncIterator<ExamSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sessionName: () => Promise<AsyncIterator<String>>;
  sessionCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamSessionNullablePromise
  extends Promise<ExamSession | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateExam {
  count: Int;
}

export interface AggregateExamPromise
  extends Promise<AggregateExam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExamSubscription
  extends Promise<AsyncIterator<AggregateExam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface examCenterEdge {
  node: examCenter;
  cursor: String;
}

export interface examCenterEdgePromise
  extends Promise<examCenterEdge>,
    Fragmentable {
  node: <T = examCenterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface examCenterEdgeSubscription
  extends Promise<AsyncIterator<examCenterEdge>>,
    Fragmentable {
  node: <T = examCenterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExamEdge {
  node: Exam;
  cursor: String;
}

export interface ExamEdgePromise extends Promise<ExamEdge>, Fragmentable {
  node: <T = ExamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExamEdgeSubscription
  extends Promise<AsyncIterator<ExamEdge>>,
    Fragmentable {
  node: <T = ExamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface examCenter {
  id: ID_Output;
  centerName: String;
  centerCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface examCenterPromise extends Promise<examCenter>, Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  town: <T = TownPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface examCenterSubscription
  extends Promise<AsyncIterator<examCenter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  centerName: () => Promise<AsyncIterator<String>>;
  centerCode: () => Promise<AsyncIterator<String>>;
  town: <T = TownSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface examCenterNullablePromise
  extends Promise<examCenter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  town: <T = TownPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamConnection {
  pageInfo: PageInfo;
  edges: ExamEdge[];
}

export interface ExamConnectionPromise
  extends Promise<ExamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExamEdge>>() => T;
  aggregate: <T = AggregateExamPromise>() => T;
}

export interface ExamConnectionSubscription
  extends Promise<AsyncIterator<ExamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExamSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Exam {
  id: ID_Output;
  examName: String;
  examCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamPromise extends Promise<Exam>, Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamSubscription
  extends Promise<AsyncIterator<Exam>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  examName: () => Promise<AsyncIterator<String>>;
  examCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamNullablePromise
  extends Promise<Exam | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateDivision {
  count: Int;
}

export interface AggregateDivisionPromise
  extends Promise<AggregateDivision>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDivisionSubscription
  extends Promise<AsyncIterator<AggregateDivision>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TownEdge {
  node: Town;
  cursor: String;
}

export interface TownEdgePromise extends Promise<TownEdge>, Fragmentable {
  node: <T = TownPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TownEdgeSubscription
  extends Promise<AsyncIterator<TownEdge>>,
    Fragmentable {
  node: <T = TownSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CandidateSubscriptionPayload {
  mutation: MutationType;
  node: Candidate;
  updatedFields: String[];
  previousValues: CandidatePreviousValues;
}

export interface CandidateSubscriptionPayloadPromise
  extends Promise<CandidateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CandidatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CandidatePreviousValuesPromise>() => T;
}

export interface CandidateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CandidateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CandidateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CandidatePreviousValuesSubscription>() => T;
}

export interface Town {
  id: ID_Output;
  townName: String;
  townCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TownPromise extends Promise<Town>, Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  subDiv: <T = SubDivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TownSubscription
  extends Promise<AsyncIterator<Town>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  townName: () => Promise<AsyncIterator<String>>;
  townCode: () => Promise<AsyncIterator<String>>;
  subDiv: <T = SubDivisionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TownNullablePromise
  extends Promise<Town | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  subDiv: <T = SubDivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CandidatePreviousValues {
  id: ID_Output;
  cand1stName?: String;
  cand2ndName?: String;
  cand3rdName?: String;
  placeOfBirth?: String;
  candCode?: String;
  image?: String;
  birthCertNumber?: String;
  email?: String;
  phoneNumb?: Int;
  dateOfBirth?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CandidatePreviousValuesPromise
  extends Promise<CandidatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cand1stName: () => Promise<String>;
  cand2ndName: () => Promise<String>;
  cand3rdName: () => Promise<String>;
  placeOfBirth: () => Promise<String>;
  candCode: () => Promise<String>;
  image: () => Promise<String>;
  birthCertNumber: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumb: () => Promise<Int>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CandidatePreviousValuesSubscription
  extends Promise<AsyncIterator<CandidatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cand1stName: () => Promise<AsyncIterator<String>>;
  cand2ndName: () => Promise<AsyncIterator<String>>;
  cand3rdName: () => Promise<AsyncIterator<String>>;
  placeOfBirth: () => Promise<AsyncIterator<String>>;
  candCode: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  birthCertNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumb: () => Promise<AsyncIterator<Int>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DivisionEdge {
  node: Division;
  cursor: String;
}

export interface DivisionEdgePromise
  extends Promise<DivisionEdge>,
    Fragmentable {
  node: <T = DivisionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DivisionEdgeSubscription
  extends Promise<AsyncIterator<DivisionEdge>>,
    Fragmentable {
  node: <T = DivisionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Subject {
  id: ID_Output;
  subjName: String;
  subjCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjName: () => Promise<AsyncIterator<String>>;
  subjCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubjectNullablePromise
  extends Promise<Subject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionSubscriptionPayload {
  mutation: MutationType;
  node: Division;
  updatedFields: String[];
  previousValues: DivisionPreviousValues;
}

export interface DivisionSubscriptionPayloadPromise
  extends Promise<DivisionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DivisionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DivisionPreviousValuesPromise>() => T;
}

export interface DivisionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DivisionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DivisionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DivisionPreviousValuesSubscription>() => T;
}

export interface SubDivisionEdge {
  node: SubDivision;
  cursor: String;
}

export interface SubDivisionEdgePromise
  extends Promise<SubDivisionEdge>,
    Fragmentable {
  node: <T = SubDivisionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubDivisionEdgeSubscription
  extends Promise<AsyncIterator<SubDivisionEdge>>,
    Fragmentable {
  node: <T = SubDivisionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DivisionPreviousValues {
  id: ID_Output;
  divName: String;
  divCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DivisionPreviousValuesPromise
  extends Promise<DivisionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionPreviousValuesSubscription
  extends Promise<AsyncIterator<DivisionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  divName: () => Promise<AsyncIterator<String>>;
  divCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubDivision {
  id: ID_Output;
  subDivName: String;
  subDivCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubDivisionPromise extends Promise<SubDivision>, Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  division: <T = DivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubDivisionSubscription
  extends Promise<AsyncIterator<SubDivision>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subDivName: () => Promise<AsyncIterator<String>>;
  subDivCode: () => Promise<AsyncIterator<String>>;
  division: <T = DivisionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubDivisionNullablePromise
  extends Promise<SubDivision | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  division: <T = DivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionConnection {
  pageInfo: PageInfo;
  edges: DivisionEdge[];
}

export interface DivisionConnectionPromise
  extends Promise<DivisionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DivisionEdge>>() => T;
  aggregate: <T = AggregateDivisionPromise>() => T;
}

export interface DivisionConnectionSubscription
  extends Promise<AsyncIterator<DivisionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DivisionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDivisionSubscription>() => T;
}

export interface SeriesEdge {
  node: Series;
  cursor: String;
}

export interface SeriesEdgePromise extends Promise<SeriesEdge>, Fragmentable {
  node: <T = SeriesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeriesEdgeSubscription
  extends Promise<AsyncIterator<SeriesEdge>>,
    Fragmentable {
  node: <T = SeriesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExamSubscriptionPayload {
  mutation: MutationType;
  node: Exam;
  updatedFields: String[];
  previousValues: ExamPreviousValues;
}

export interface ExamSubscriptionPayloadPromise
  extends Promise<ExamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExamPreviousValuesPromise>() => T;
}

export interface ExamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExamPreviousValuesSubscription>() => T;
}

export interface Series {
  id: ID_Output;
  seriesName: String;
  seriesCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeriesPromise extends Promise<Series>, Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeriesSubscription
  extends Promise<AsyncIterator<Series>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seriesName: () => Promise<AsyncIterator<String>>;
  seriesCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SeriesNullablePromise
  extends Promise<Series | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamPreviousValues {
  id: ID_Output;
  examName: String;
  examCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamPreviousValuesPromise
  extends Promise<ExamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamPreviousValuesSubscription
  extends Promise<AsyncIterator<ExamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  examName: () => Promise<AsyncIterator<String>>;
  examCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegionEdge {
  node: Region;
  cursor: String;
}

export interface RegionEdgePromise extends Promise<RegionEdge>, Fragmentable {
  node: <T = RegionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegionEdgeSubscription
  extends Promise<AsyncIterator<RegionEdge>>,
    Fragmentable {
  node: <T = RegionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Region {
  id: ID_Output;
  regName: String;
  regCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegionPromise extends Promise<Region>, Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  division: <T = FragmentableArray<Division>>(args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionSubscription
  extends Promise<AsyncIterator<Region>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<String>>;
  regCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  division: <T = Promise<AsyncIterator<DivisionSubscription>>>(args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionNullablePromise
  extends Promise<Region | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  division: <T = FragmentableArray<Division>>(args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregatePresence {
  count: Int;
}

export interface AggregatePresencePromise
  extends Promise<AggregatePresence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePresenceSubscription
  extends Promise<AsyncIterator<AggregatePresence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExamSessionSubscriptionPayload {
  mutation: MutationType;
  node: ExamSession;
  updatedFields: String[];
  previousValues: ExamSessionPreviousValues;
}

export interface ExamSessionSubscriptionPayloadPromise
  extends Promise<ExamSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExamSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExamSessionPreviousValuesPromise>() => T;
}

export interface ExamSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExamSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExamSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExamSessionPreviousValuesSubscription>() => T;
}

export interface PresenceConnection {
  pageInfo: PageInfo;
  edges: PresenceEdge[];
}

export interface PresenceConnectionPromise
  extends Promise<PresenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PresenceEdge>>() => T;
  aggregate: <T = AggregatePresencePromise>() => T;
}

export interface PresenceConnectionSubscription
  extends Promise<AsyncIterator<PresenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PresenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePresenceSubscription>() => T;
}

export interface ExamSessionPreviousValues {
  id: ID_Output;
  sessionName: String;
  sessionCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamSessionPreviousValuesPromise
  extends Promise<ExamSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<ExamSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sessionName: () => Promise<AsyncIterator<String>>;
  sessionCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Division {
  id: ID_Output;
  divName: String;
  divCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DivisionPromise extends Promise<Division>, Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  region: <T = RegionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionSubscription
  extends Promise<AsyncIterator<Division>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  divName: () => Promise<AsyncIterator<String>>;
  divCode: () => Promise<AsyncIterator<String>>;
  region: <T = RegionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DivisionNullablePromise
  extends Promise<Division | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  region: <T = RegionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface GenderSubscriptionPayload {
  mutation: MutationType;
  node: Gender;
  updatedFields: String[];
  previousValues: GenderPreviousValues;
}

export interface GenderSubscriptionPayloadPromise
  extends Promise<GenderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GenderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GenderPreviousValuesPromise>() => T;
}

export interface GenderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GenderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GenderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GenderPreviousValuesSubscription>() => T;
}

export interface AggregateGender {
  count: Int;
}

export interface AggregateGenderPromise
  extends Promise<AggregateGender>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGenderSubscription
  extends Promise<AsyncIterator<AggregateGender>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GenderPreviousValues {
  id: ID_Output;
  genderName: String;
  genderCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GenderPreviousValuesPromise
  extends Promise<GenderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  genderName: () => Promise<String>;
  genderCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GenderPreviousValuesSubscription
  extends Promise<AsyncIterator<GenderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  genderName: () => Promise<AsyncIterator<String>>;
  genderCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GenderConnection {
  pageInfo: PageInfo;
  edges: GenderEdge[];
}

export interface GenderConnectionPromise
  extends Promise<GenderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GenderEdge>>() => T;
  aggregate: <T = AggregateGenderPromise>() => T;
}

export interface GenderConnectionSubscription
  extends Promise<AsyncIterator<GenderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GenderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGenderSubscription>() => T;
}

export interface AggregateCandidate {
  count: Int;
}

export interface AggregateCandidatePromise
  extends Promise<AggregateCandidate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCandidateSubscription
  extends Promise<AsyncIterator<AggregateCandidate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateExamSession {
  count: Int;
}

export interface AggregateExamSessionPromise
  extends Promise<AggregateExamSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExamSessionSubscription
  extends Promise<AsyncIterator<AggregateExamSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface AggregateexamCenter {
  count: Int;
}

export interface AggregateexamCenterPromise
  extends Promise<AggregateexamCenter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateexamCenterSubscription
  extends Promise<AsyncIterator<AggregateexamCenter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemPreviousValues {
  id: ID_Output;
  title: String;
  descrption: String;
  image?: String;
  largeImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  descrption: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  descrption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CandidateEdge {
  node: Candidate;
  cursor: String;
}

export interface CandidateEdgePromise
  extends Promise<CandidateEdge>,
    Fragmentable {
  node: <T = CandidatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CandidateEdgeSubscription
  extends Promise<AsyncIterator<CandidateEdge>>,
    Fragmentable {
  node: <T = CandidateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTown {
  count: Int;
}

export interface AggregateTownPromise
  extends Promise<AggregateTown>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTownSubscription
  extends Promise<AsyncIterator<AggregateTown>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PresenceSubscriptionPayload {
  mutation: MutationType;
  node: Presence;
  updatedFields: String[];
  previousValues: PresencePreviousValues;
}

export interface PresenceSubscriptionPayloadPromise
  extends Promise<PresenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PresencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PresencePreviousValuesPromise>() => T;
}

export interface PresenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PresenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PresenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PresencePreviousValuesSubscription>() => T;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PresencePreviousValues {
  id: ID_Output;
  presenceName: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PresencePreviousValuesPromise
  extends Promise<PresencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  presenceName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PresencePreviousValuesSubscription
  extends Promise<AsyncIterator<PresencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  presenceName: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSubDivision {
  count: Int;
}

export interface AggregateSubDivisionPromise
  extends Promise<AggregateSubDivision>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubDivisionSubscription
  extends Promise<AsyncIterator<AggregateSubDivision>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface examCenterSubscriptionPayload {
  mutation: MutationType;
  node: examCenter;
  updatedFields: String[];
  previousValues: examCenterPreviousValues;
}

export interface examCenterSubscriptionPayloadPromise
  extends Promise<examCenterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = examCenterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = examCenterPreviousValuesPromise>() => T;
}

export interface examCenterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<examCenterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = examCenterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = examCenterPreviousValuesSubscription>() => T;
}

export interface AggregateSeries {
  count: Int;
}

export interface AggregateSeriesPromise
  extends Promise<AggregateSeries>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeriesSubscription
  extends Promise<AsyncIterator<AggregateSeries>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegionSubscriptionPayload {
  mutation: MutationType;
  node: Region;
  updatedFields: String[];
  previousValues: RegionPreviousValues;
}

export interface RegionSubscriptionPayloadPromise
  extends Promise<RegionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegionPreviousValuesPromise>() => T;
}

export interface RegionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegionPreviousValuesSubscription>() => T;
}

export interface AggregateRegion {
  count: Int;
}

export interface AggregateRegionPromise
  extends Promise<AggregateRegion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegionSubscription
  extends Promise<AsyncIterator<AggregateRegion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegionPreviousValues {
  id: ID_Output;
  regName: String;
  regCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegionPreviousValuesPromise
  extends Promise<RegionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegionPreviousValuesSubscription
  extends Promise<AsyncIterator<RegionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<String>>;
  regCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PresenceEdge {
  node: Presence;
  cursor: String;
}

export interface PresenceEdgePromise
  extends Promise<PresenceEdge>,
    Fragmentable {
  node: <T = PresencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PresenceEdgeSubscription
  extends Promise<AsyncIterator<PresenceEdge>>,
    Fragmentable {
  node: <T = PresenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SeriesSubscriptionPayload {
  mutation: MutationType;
  node: Series;
  updatedFields: String[];
  previousValues: SeriesPreviousValues;
}

export interface SeriesSubscriptionPayloadPromise
  extends Promise<SeriesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeriesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeriesPreviousValuesPromise>() => T;
}

export interface SeriesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeriesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeriesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeriesPreviousValuesSubscription>() => T;
}

export interface GenderEdge {
  node: Gender;
  cursor: String;
}

export interface GenderEdgePromise extends Promise<GenderEdge>, Fragmentable {
  node: <T = GenderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GenderEdgeSubscription
  extends Promise<AsyncIterator<GenderEdge>>,
    Fragmentable {
  node: <T = GenderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SeriesPreviousValues {
  id: ID_Output;
  seriesName: String;
  seriesCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeriesPreviousValuesPromise
  extends Promise<SeriesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeriesPreviousValuesSubscription
  extends Promise<AsyncIterator<SeriesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seriesName: () => Promise<AsyncIterator<String>>;
  seriesCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamSessionEdge {
  node: ExamSession;
  cursor: String;
}

export interface ExamSessionEdgePromise
  extends Promise<ExamSessionEdge>,
    Fragmentable {
  node: <T = ExamSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExamSessionEdgeSubscription
  extends Promise<AsyncIterator<ExamSessionEdge>>,
    Fragmentable {
  node: <T = ExamSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CandidateConnection {
  pageInfo: PageInfo;
  edges: CandidateEdge[];
}

export interface CandidateConnectionPromise
  extends Promise<CandidateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CandidateEdge>>() => T;
  aggregate: <T = AggregateCandidatePromise>() => T;
}

export interface CandidateConnectionSubscription
  extends Promise<AsyncIterator<CandidateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CandidateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCandidateSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface SubDivisionSubscriptionPayload {
  mutation: MutationType;
  node: SubDivision;
  updatedFields: String[];
  previousValues: SubDivisionPreviousValues;
}

export interface SubDivisionSubscriptionPayloadPromise
  extends Promise<SubDivisionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubDivisionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubDivisionPreviousValuesPromise>() => T;
}

export interface SubDivisionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubDivisionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubDivisionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubDivisionPreviousValuesSubscription>() => T;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface SubDivisionPreviousValues {
  id: ID_Output;
  subDivName: String;
  subDivCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubDivisionPreviousValuesPromise
  extends Promise<SubDivisionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubDivisionPreviousValuesSubscription
  extends Promise<AsyncIterator<SubDivisionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subDivName: () => Promise<AsyncIterator<String>>;
  subDivCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SeriesConnection {
  pageInfo: PageInfo;
  edges: SeriesEdge[];
}

export interface SeriesConnectionPromise
  extends Promise<SeriesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeriesEdge>>() => T;
  aggregate: <T = AggregateSeriesPromise>() => T;
}

export interface SeriesConnectionSubscription
  extends Promise<AsyncIterator<SeriesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeriesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeriesSubscription>() => T;
}

export interface Candidate {
  id: ID_Output;
  cand1stName?: String;
  cand2ndName?: String;
  cand3rdName?: String;
  placeOfBirth?: String;
  candCode?: String;
  image?: String;
  birthCertNumber?: String;
  email?: String;
  phoneNumb?: Int;
  dateOfBirth?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CandidatePromise extends Promise<Candidate>, Fragmentable {
  id: () => Promise<ID_Output>;
  cand1stName: () => Promise<String>;
  cand2ndName: () => Promise<String>;
  cand3rdName: () => Promise<String>;
  placeOfBirth: () => Promise<String>;
  candCode: () => Promise<String>;
  image: () => Promise<String>;
  birthCertNumber: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumb: () => Promise<Int>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CandidateSubscription
  extends Promise<AsyncIterator<Candidate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cand1stName: () => Promise<AsyncIterator<String>>;
  cand2ndName: () => Promise<AsyncIterator<String>>;
  cand3rdName: () => Promise<AsyncIterator<String>>;
  placeOfBirth: () => Promise<AsyncIterator<String>>;
  candCode: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  birthCertNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumb: () => Promise<AsyncIterator<Int>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CandidateNullablePromise
  extends Promise<Candidate | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cand1stName: () => Promise<String>;
  cand2ndName: () => Promise<String>;
  cand3rdName: () => Promise<String>;
  placeOfBirth: () => Promise<String>;
  candCode: () => Promise<String>;
  image: () => Promise<String>;
  birthCertNumber: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumb: () => Promise<Int>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Presence {
  id: ID_Output;
  presenceName: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PresencePromise extends Promise<Presence>, Fragmentable {
  id: () => Promise<ID_Output>;
  presenceName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PresenceSubscription
  extends Promise<AsyncIterator<Presence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  presenceName: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PresenceNullablePromise
  extends Promise<Presence | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  presenceName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface Gender {
  id: ID_Output;
  genderName: String;
  genderCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GenderPromise extends Promise<Gender>, Fragmentable {
  id: () => Promise<ID_Output>;
  genderName: () => Promise<String>;
  genderCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GenderSubscription
  extends Promise<AsyncIterator<Gender>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  genderName: () => Promise<AsyncIterator<String>>;
  genderCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GenderNullablePromise
  extends Promise<Gender | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  genderName: () => Promise<String>;
  genderCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TownConnection {
  pageInfo: PageInfo;
  edges: TownEdge[];
}

export interface TownConnectionPromise
  extends Promise<TownConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TownEdge>>() => T;
  aggregate: <T = AggregateTownPromise>() => T;
}

export interface TownConnectionSubscription
  extends Promise<AsyncIterator<TownConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TownEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTownSubscription>() => T;
}

export interface TownPreviousValues {
  id: ID_Output;
  townName: String;
  townCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TownPreviousValuesPromise
  extends Promise<TownPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TownPreviousValuesSubscription
  extends Promise<AsyncIterator<TownPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  townName: () => Promise<AsyncIterator<String>>;
  townCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TownSubscriptionPayload {
  mutation: MutationType;
  node: Town;
  updatedFields: String[];
  previousValues: TownPreviousValues;
}

export interface TownSubscriptionPayloadPromise
  extends Promise<TownSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TownPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TownPreviousValuesPromise>() => T;
}

export interface TownSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TownSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TownSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TownPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubjectPreviousValues {
  id: ID_Output;
  subjName: String;
  subjCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjName: () => Promise<AsyncIterator<String>>;
  subjCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubDivisionConnection {
  pageInfo: PageInfo;
  edges: SubDivisionEdge[];
}

export interface SubDivisionConnectionPromise
  extends Promise<SubDivisionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubDivisionEdge>>() => T;
  aggregate: <T = AggregateSubDivisionPromise>() => T;
}

export interface SubDivisionConnectionSubscription
  extends Promise<AsyncIterator<SubDivisionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubDivisionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubDivisionSubscription>() => T;
}

export interface examCenterConnection {
  pageInfo: PageInfo;
  edges: examCenterEdge[];
}

export interface examCenterConnectionPromise
  extends Promise<examCenterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<examCenterEdge>>() => T;
  aggregate: <T = AggregateexamCenterPromise>() => T;
}

export interface examCenterConnectionSubscription
  extends Promise<AsyncIterator<examCenterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<examCenterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateexamCenterSubscription>() => T;
}

export interface Item {
  id: ID_Output;
  title: String;
  descrption: String;
  image?: String;
  largeImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  descrption: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  descrption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  descrption: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegionConnection {
  pageInfo: PageInfo;
  edges: RegionEdge[];
}

export interface RegionConnectionPromise
  extends Promise<RegionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegionEdge>>() => T;
  aggregate: <T = AggregateRegionPromise>() => T;
}

export interface RegionConnectionSubscription
  extends Promise<AsyncIterator<RegionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegionSubscription>() => T;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Region",
    embedded: false
  },
  {
    name: "Division",
    embedded: false
  },
  {
    name: "SubDivision",
    embedded: false
  },
  {
    name: "Town",
    embedded: false
  },
  {
    name: "examCenter",
    embedded: false
  },
  {
    name: "Series",
    embedded: false
  },
  {
    name: "Exam",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "Presence",
    embedded: false
  },
  {
    name: "ExamSession",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Candidate",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
