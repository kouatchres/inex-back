// Code generated by Prisma (prisma@1.34.5). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  division: (where?: DivisionWhereInput) => Promise<boolean>;
  exam: (where?: ExamWhereInput) => Promise<boolean>;
  presence: (where?: PresenceWhereInput) => Promise<boolean>;
  region: (where?: RegionWhereInput) => Promise<boolean>;
  series: (where?: SeriesWhereInput) => Promise<boolean>;
  subDivision: (where?: SubDivisionWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  town: (where?: TownWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  examSession: (where?: examSessionWhereInput) => Promise<boolean>;
  exanCenter: (where?: exanCenterWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  division: (where: DivisionWhereUniqueInput) => DivisionNullablePromise;
  divisions: (args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Division>;
  divisionsConnection: (args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DivisionConnectionPromise;
  exam: (where: ExamWhereUniqueInput) => ExamNullablePromise;
  exams: (args?: {
    where?: ExamWhereInput;
    orderBy?: ExamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Exam>;
  examsConnection: (args?: {
    where?: ExamWhereInput;
    orderBy?: ExamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExamConnectionPromise;
  presence: (where: PresenceWhereUniqueInput) => PresenceNullablePromise;
  presences: (args?: {
    where?: PresenceWhereInput;
    orderBy?: PresenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Presence>;
  presencesConnection: (args?: {
    where?: PresenceWhereInput;
    orderBy?: PresenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PresenceConnectionPromise;
  region: (where: RegionWhereUniqueInput) => RegionNullablePromise;
  regions: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Region>;
  regionsConnection: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegionConnectionPromise;
  series: (where: SeriesWhereUniqueInput) => SeriesNullablePromise;
  serieses: (args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Series>;
  seriesesConnection: (args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SeriesConnectionPromise;
  subDivision: (
    where: SubDivisionWhereUniqueInput
  ) => SubDivisionNullablePromise;
  subDivisions: (args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubDivision>;
  subDivisionsConnection: (args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubDivisionConnectionPromise;
  subject: (where: SubjectWhereUniqueInput) => SubjectNullablePromise;
  subjects: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Subject>;
  subjectsConnection: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectConnectionPromise;
  town: (where: TownWhereUniqueInput) => TownNullablePromise;
  towns: (args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Town>;
  townsConnection: (args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TownConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  examSession: (
    where: examSessionWhereUniqueInput
  ) => examSessionNullablePromise;
  examSessions: (args?: {
    where?: examSessionWhereInput;
    orderBy?: examSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<examSession>;
  examSessionsConnection: (args?: {
    where?: examSessionWhereInput;
    orderBy?: examSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => examSessionConnectionPromise;
  exanCenter: (where: exanCenterWhereUniqueInput) => exanCenterNullablePromise;
  exanCenters: (args?: {
    where?: exanCenterWhereInput;
    orderBy?: exanCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<exanCenter>;
  exanCentersConnection: (args?: {
    where?: exanCenterWhereInput;
    orderBy?: exanCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => exanCenterConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDivision: (data: DivisionCreateInput) => DivisionPromise;
  updateDivision: (args: {
    data: DivisionUpdateInput;
    where: DivisionWhereUniqueInput;
  }) => DivisionPromise;
  updateManyDivisions: (args: {
    data: DivisionUpdateManyMutationInput;
    where?: DivisionWhereInput;
  }) => BatchPayloadPromise;
  upsertDivision: (args: {
    where: DivisionWhereUniqueInput;
    create: DivisionCreateInput;
    update: DivisionUpdateInput;
  }) => DivisionPromise;
  deleteDivision: (where: DivisionWhereUniqueInput) => DivisionPromise;
  deleteManyDivisions: (where?: DivisionWhereInput) => BatchPayloadPromise;
  createExam: (data: ExamCreateInput) => ExamPromise;
  updateExam: (args: {
    data: ExamUpdateInput;
    where: ExamWhereUniqueInput;
  }) => ExamPromise;
  updateManyExams: (args: {
    data: ExamUpdateManyMutationInput;
    where?: ExamWhereInput;
  }) => BatchPayloadPromise;
  upsertExam: (args: {
    where: ExamWhereUniqueInput;
    create: ExamCreateInput;
    update: ExamUpdateInput;
  }) => ExamPromise;
  deleteExam: (where: ExamWhereUniqueInput) => ExamPromise;
  deleteManyExams: (where?: ExamWhereInput) => BatchPayloadPromise;
  createPresence: (data: PresenceCreateInput) => PresencePromise;
  updatePresence: (args: {
    data: PresenceUpdateInput;
    where: PresenceWhereUniqueInput;
  }) => PresencePromise;
  updateManyPresences: (args: {
    data: PresenceUpdateManyMutationInput;
    where?: PresenceWhereInput;
  }) => BatchPayloadPromise;
  upsertPresence: (args: {
    where: PresenceWhereUniqueInput;
    create: PresenceCreateInput;
    update: PresenceUpdateInput;
  }) => PresencePromise;
  deletePresence: (where: PresenceWhereUniqueInput) => PresencePromise;
  deleteManyPresences: (where?: PresenceWhereInput) => BatchPayloadPromise;
  createRegion: (data: RegionCreateInput) => RegionPromise;
  updateRegion: (args: {
    data: RegionUpdateInput;
    where: RegionWhereUniqueInput;
  }) => RegionPromise;
  updateManyRegions: (args: {
    data: RegionUpdateManyMutationInput;
    where?: RegionWhereInput;
  }) => BatchPayloadPromise;
  upsertRegion: (args: {
    where: RegionWhereUniqueInput;
    create: RegionCreateInput;
    update: RegionUpdateInput;
  }) => RegionPromise;
  deleteRegion: (where: RegionWhereUniqueInput) => RegionPromise;
  deleteManyRegions: (where?: RegionWhereInput) => BatchPayloadPromise;
  createSeries: (data: SeriesCreateInput) => SeriesPromise;
  updateSeries: (args: {
    data: SeriesUpdateInput;
    where: SeriesWhereUniqueInput;
  }) => SeriesPromise;
  updateManySerieses: (args: {
    data: SeriesUpdateManyMutationInput;
    where?: SeriesWhereInput;
  }) => BatchPayloadPromise;
  upsertSeries: (args: {
    where: SeriesWhereUniqueInput;
    create: SeriesCreateInput;
    update: SeriesUpdateInput;
  }) => SeriesPromise;
  deleteSeries: (where: SeriesWhereUniqueInput) => SeriesPromise;
  deleteManySerieses: (where?: SeriesWhereInput) => BatchPayloadPromise;
  createSubDivision: (data: SubDivisionCreateInput) => SubDivisionPromise;
  updateSubDivision: (args: {
    data: SubDivisionUpdateInput;
    where: SubDivisionWhereUniqueInput;
  }) => SubDivisionPromise;
  updateManySubDivisions: (args: {
    data: SubDivisionUpdateManyMutationInput;
    where?: SubDivisionWhereInput;
  }) => BatchPayloadPromise;
  upsertSubDivision: (args: {
    where: SubDivisionWhereUniqueInput;
    create: SubDivisionCreateInput;
    update: SubDivisionUpdateInput;
  }) => SubDivisionPromise;
  deleteSubDivision: (where: SubDivisionWhereUniqueInput) => SubDivisionPromise;
  deleteManySubDivisions: (
    where?: SubDivisionWhereInput
  ) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateSubject: (args: {
    data: SubjectUpdateInput;
    where: SubjectWhereUniqueInput;
  }) => SubjectPromise;
  updateManySubjects: (args: {
    data: SubjectUpdateManyMutationInput;
    where?: SubjectWhereInput;
  }) => BatchPayloadPromise;
  upsertSubject: (args: {
    where: SubjectWhereUniqueInput;
    create: SubjectCreateInput;
    update: SubjectUpdateInput;
  }) => SubjectPromise;
  deleteSubject: (where: SubjectWhereUniqueInput) => SubjectPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createTown: (data: TownCreateInput) => TownPromise;
  updateTown: (args: {
    data: TownUpdateInput;
    where: TownWhereUniqueInput;
  }) => TownPromise;
  updateManyTowns: (args: {
    data: TownUpdateManyMutationInput;
    where?: TownWhereInput;
  }) => BatchPayloadPromise;
  upsertTown: (args: {
    where: TownWhereUniqueInput;
    create: TownCreateInput;
    update: TownUpdateInput;
  }) => TownPromise;
  deleteTown: (where: TownWhereUniqueInput) => TownPromise;
  deleteManyTowns: (where?: TownWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createexamSession: (data: examSessionCreateInput) => examSessionPromise;
  updateexamSession: (args: {
    data: examSessionUpdateInput;
    where: examSessionWhereUniqueInput;
  }) => examSessionPromise;
  updateManyexamSessions: (args: {
    data: examSessionUpdateManyMutationInput;
    where?: examSessionWhereInput;
  }) => BatchPayloadPromise;
  upsertexamSession: (args: {
    where: examSessionWhereUniqueInput;
    create: examSessionCreateInput;
    update: examSessionUpdateInput;
  }) => examSessionPromise;
  deleteexamSession: (where: examSessionWhereUniqueInput) => examSessionPromise;
  deleteManyexamSessions: (
    where?: examSessionWhereInput
  ) => BatchPayloadPromise;
  createexanCenter: (data: exanCenterCreateInput) => exanCenterPromise;
  updateexanCenter: (args: {
    data: exanCenterUpdateInput;
    where: exanCenterWhereUniqueInput;
  }) => exanCenterPromise;
  updateManyexanCenters: (args: {
    data: exanCenterUpdateManyMutationInput;
    where?: exanCenterWhereInput;
  }) => BatchPayloadPromise;
  upsertexanCenter: (args: {
    where: exanCenterWhereUniqueInput;
    create: exanCenterCreateInput;
    update: exanCenterUpdateInput;
  }) => exanCenterPromise;
  deleteexanCenter: (where: exanCenterWhereUniqueInput) => exanCenterPromise;
  deleteManyexanCenters: (where?: exanCenterWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  division: (
    where?: DivisionSubscriptionWhereInput
  ) => DivisionSubscriptionPayloadSubscription;
  exam: (
    where?: ExamSubscriptionWhereInput
  ) => ExamSubscriptionPayloadSubscription;
  presence: (
    where?: PresenceSubscriptionWhereInput
  ) => PresenceSubscriptionPayloadSubscription;
  region: (
    where?: RegionSubscriptionWhereInput
  ) => RegionSubscriptionPayloadSubscription;
  series: (
    where?: SeriesSubscriptionWhereInput
  ) => SeriesSubscriptionPayloadSubscription;
  subDivision: (
    where?: SubDivisionSubscriptionWhereInput
  ) => SubDivisionSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  town: (
    where?: TownSubscriptionWhereInput
  ) => TownSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  examSession: (
    where?: examSessionSubscriptionWhereInput
  ) => examSessionSubscriptionPayloadSubscription;
  exanCenter: (
    where?: exanCenterSubscriptionWhereInput
  ) => exanCenterSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subjName_ASC"
  | "subjName_DESC"
  | "subjCode_ASC"
  | "subjCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "examName_ASC"
  | "examName_DESC"
  | "examCode_ASC"
  | "examCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DivisionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "divName_ASC"
  | "divName_DESC"
  | "divCode_ASC"
  | "divCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type exanCenterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "centerName_ASC"
  | "centerName_DESC"
  | "centerCode_ASC"
  | "centerCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PresenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "regName_ASC"
  | "regName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RegionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "regName_ASC"
  | "regName_DESC"
  | "regCode_ASC"
  | "regCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SeriesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "seriesName_ASC"
  | "seriesName_DESC"
  | "seriesCode_ASC"
  | "seriesCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubDivisionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subDivName_ASC"
  | "subDivName_DESC"
  | "subDivCode_ASC"
  | "subDivCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type examSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sessionName_ASC"
  | "sessionName_DESC"
  | "sessionCode_ASC"
  | "sessionCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type TownOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "townName_ASC"
  | "townName_DESC"
  | "townCode_ASC"
  | "townCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC";

export interface DivisionCreateInput {
  id?: Maybe<ID_Input>;
  divName: String;
  divCode: String;
  region: RegionCreateOneInput;
}

export type DivisionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TownWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExamUpdateInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
}

export interface TownUpdateInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
  subDiv?: Maybe<SubDivisionUpdateOneRequiredInput>;
}

export interface DivisionUpdateManyMutationInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
}

export interface TownWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  townName?: Maybe<String>;
  townName_not?: Maybe<String>;
  townName_in?: Maybe<String[] | String>;
  townName_not_in?: Maybe<String[] | String>;
  townName_lt?: Maybe<String>;
  townName_lte?: Maybe<String>;
  townName_gt?: Maybe<String>;
  townName_gte?: Maybe<String>;
  townName_contains?: Maybe<String>;
  townName_not_contains?: Maybe<String>;
  townName_starts_with?: Maybe<String>;
  townName_not_starts_with?: Maybe<String>;
  townName_ends_with?: Maybe<String>;
  townName_not_ends_with?: Maybe<String>;
  townCode?: Maybe<String>;
  townCode_not?: Maybe<String>;
  townCode_in?: Maybe<String[] | String>;
  townCode_not_in?: Maybe<String[] | String>;
  townCode_lt?: Maybe<String>;
  townCode_lte?: Maybe<String>;
  townCode_gt?: Maybe<String>;
  townCode_gte?: Maybe<String>;
  townCode_contains?: Maybe<String>;
  townCode_not_contains?: Maybe<String>;
  townCode_starts_with?: Maybe<String>;
  townCode_not_starts_with?: Maybe<String>;
  townCode_ends_with?: Maybe<String>;
  townCode_not_ends_with?: Maybe<String>;
  subDiv?: Maybe<SubDivisionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TownWhereInput[] | TownWhereInput>;
  OR?: Maybe<TownWhereInput[] | TownWhereInput>;
  NOT?: Maybe<TownWhereInput[] | TownWhereInput>;
}

export interface ExamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  examName?: Maybe<String>;
  examName_not?: Maybe<String>;
  examName_in?: Maybe<String[] | String>;
  examName_not_in?: Maybe<String[] | String>;
  examName_lt?: Maybe<String>;
  examName_lte?: Maybe<String>;
  examName_gt?: Maybe<String>;
  examName_gte?: Maybe<String>;
  examName_contains?: Maybe<String>;
  examName_not_contains?: Maybe<String>;
  examName_starts_with?: Maybe<String>;
  examName_not_starts_with?: Maybe<String>;
  examName_ends_with?: Maybe<String>;
  examName_not_ends_with?: Maybe<String>;
  examCode?: Maybe<String>;
  examCode_not?: Maybe<String>;
  examCode_in?: Maybe<String[] | String>;
  examCode_not_in?: Maybe<String[] | String>;
  examCode_lt?: Maybe<String>;
  examCode_lte?: Maybe<String>;
  examCode_gt?: Maybe<String>;
  examCode_gte?: Maybe<String>;
  examCode_contains?: Maybe<String>;
  examCode_not_contains?: Maybe<String>;
  examCode_starts_with?: Maybe<String>;
  examCode_not_starts_with?: Maybe<String>;
  examCode_ends_with?: Maybe<String>;
  examCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExamWhereInput[] | ExamWhereInput>;
  OR?: Maybe<ExamWhereInput[] | ExamWhereInput>;
  NOT?: Maybe<ExamWhereInput[] | ExamWhereInput>;
}

export interface DivisionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  divName?: Maybe<String>;
  divName_not?: Maybe<String>;
  divName_in?: Maybe<String[] | String>;
  divName_not_in?: Maybe<String[] | String>;
  divName_lt?: Maybe<String>;
  divName_lte?: Maybe<String>;
  divName_gt?: Maybe<String>;
  divName_gte?: Maybe<String>;
  divName_contains?: Maybe<String>;
  divName_not_contains?: Maybe<String>;
  divName_starts_with?: Maybe<String>;
  divName_not_starts_with?: Maybe<String>;
  divName_ends_with?: Maybe<String>;
  divName_not_ends_with?: Maybe<String>;
  divCode?: Maybe<String>;
  divCode_not?: Maybe<String>;
  divCode_in?: Maybe<String[] | String>;
  divCode_not_in?: Maybe<String[] | String>;
  divCode_lt?: Maybe<String>;
  divCode_lte?: Maybe<String>;
  divCode_gt?: Maybe<String>;
  divCode_gte?: Maybe<String>;
  divCode_contains?: Maybe<String>;
  divCode_not_contains?: Maybe<String>;
  divCode_starts_with?: Maybe<String>;
  divCode_not_starts_with?: Maybe<String>;
  divCode_ends_with?: Maybe<String>;
  divCode_not_ends_with?: Maybe<String>;
  region?: Maybe<RegionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
  OR?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
  NOT?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface SubDivisionCreateOneInput {
  create?: Maybe<SubDivisionCreateInput>;
  connect?: Maybe<SubDivisionWhereUniqueInput>;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubjectWhereInput>;
  AND?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  OR?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  NOT?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
}

export interface TownCreateInput {
  id?: Maybe<ID_Input>;
  townName: String;
  townCode: String;
  subDiv: SubDivisionCreateOneInput;
}

export interface SubDivisionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubDivisionWhereInput>;
  AND?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
  OR?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
}

export interface SubjectUpdateManyMutationInput {
  subjName?: Maybe<String>;
  subjCode?: Maybe<String>;
}

export interface SeriesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SeriesWhereInput>;
  AND?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
  OR?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
  NOT?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PresenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PresenceWhereInput>;
  AND?: Maybe<
    PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput
  >;
  OR?: Maybe<PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput>;
  NOT?: Maybe<
    PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput
  >;
}

export interface SubjectUpdateInput {
  subjName?: Maybe<String>;
  subjCode?: Maybe<String>;
}

export type RegionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface exanCenterUpdateManyMutationInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
}

export interface SubjectCreateInput {
  id?: Maybe<ID_Input>;
  subjName: String;
  subjCode: String;
}

export interface TownUpdateDataInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
  subDiv?: Maybe<SubDivisionUpdateOneRequiredInput>;
}

export interface SubDivisionUpdateManyMutationInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
}

export interface TownUpdateOneRequiredInput {
  create?: Maybe<TownCreateInput>;
  update?: Maybe<TownUpdateDataInput>;
  upsert?: Maybe<TownUpsertNestedInput>;
  connect?: Maybe<TownWhereUniqueInput>;
}

export interface DivisionUpsertNestedInput {
  update: DivisionUpdateDataInput;
  create: DivisionCreateInput;
}

export interface exanCenterUpdateInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  town?: Maybe<TownUpdateOneRequiredInput>;
}

export interface DivisionUpdateDataInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
  region?: Maybe<RegionUpdateOneRequiredInput>;
}

export interface exanCenterCreateInput {
  id?: Maybe<ID_Input>;
  centerName: String;
  centerCode: String;
  town: TownCreateOneInput;
}

export type examSessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SubDivisionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DivisionUpdateOneRequiredInput {
  create?: Maybe<DivisionCreateInput>;
  update?: Maybe<DivisionUpdateDataInput>;
  upsert?: Maybe<DivisionUpsertNestedInput>;
  connect?: Maybe<DivisionWhereUniqueInput>;
}

export interface SubDivisionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subDivName?: Maybe<String>;
  subDivName_not?: Maybe<String>;
  subDivName_in?: Maybe<String[] | String>;
  subDivName_not_in?: Maybe<String[] | String>;
  subDivName_lt?: Maybe<String>;
  subDivName_lte?: Maybe<String>;
  subDivName_gt?: Maybe<String>;
  subDivName_gte?: Maybe<String>;
  subDivName_contains?: Maybe<String>;
  subDivName_not_contains?: Maybe<String>;
  subDivName_starts_with?: Maybe<String>;
  subDivName_not_starts_with?: Maybe<String>;
  subDivName_ends_with?: Maybe<String>;
  subDivName_not_ends_with?: Maybe<String>;
  subDivCode?: Maybe<String>;
  subDivCode_not?: Maybe<String>;
  subDivCode_in?: Maybe<String[] | String>;
  subDivCode_not_in?: Maybe<String[] | String>;
  subDivCode_lt?: Maybe<String>;
  subDivCode_lte?: Maybe<String>;
  subDivCode_gt?: Maybe<String>;
  subDivCode_gte?: Maybe<String>;
  subDivCode_contains?: Maybe<String>;
  subDivCode_not_contains?: Maybe<String>;
  subDivCode_starts_with?: Maybe<String>;
  subDivCode_not_starts_with?: Maybe<String>;
  subDivCode_ends_with?: Maybe<String>;
  subDivCode_not_ends_with?: Maybe<String>;
  division?: Maybe<DivisionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
  OR?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
  NOT?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
}

export interface examSessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sessionName?: Maybe<String>;
  sessionName_not?: Maybe<String>;
  sessionName_in?: Maybe<String[] | String>;
  sessionName_not_in?: Maybe<String[] | String>;
  sessionName_lt?: Maybe<String>;
  sessionName_lte?: Maybe<String>;
  sessionName_gt?: Maybe<String>;
  sessionName_gte?: Maybe<String>;
  sessionName_contains?: Maybe<String>;
  sessionName_not_contains?: Maybe<String>;
  sessionName_starts_with?: Maybe<String>;
  sessionName_not_starts_with?: Maybe<String>;
  sessionName_ends_with?: Maybe<String>;
  sessionName_not_ends_with?: Maybe<String>;
  sessionCode?: Maybe<String>;
  sessionCode_not?: Maybe<String>;
  sessionCode_in?: Maybe<String[] | String>;
  sessionCode_not_in?: Maybe<String[] | String>;
  sessionCode_lt?: Maybe<String>;
  sessionCode_lte?: Maybe<String>;
  sessionCode_gt?: Maybe<String>;
  sessionCode_gte?: Maybe<String>;
  sessionCode_contains?: Maybe<String>;
  sessionCode_not_contains?: Maybe<String>;
  sessionCode_starts_with?: Maybe<String>;
  sessionCode_not_starts_with?: Maybe<String>;
  sessionCode_ends_with?: Maybe<String>;
  sessionCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<examSessionWhereInput[] | examSessionWhereInput>;
  OR?: Maybe<examSessionWhereInput[] | examSessionWhereInput>;
  NOT?: Maybe<examSessionWhereInput[] | examSessionWhereInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface SubDivisionUpdateInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateOneRequiredInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
}

export interface DivisionCreateOneInput {
  create?: Maybe<DivisionCreateInput>;
  connect?: Maybe<DivisionWhereUniqueInput>;
}

export interface TownUpdateManyMutationInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
}

export interface SubDivisionCreateInput {
  id?: Maybe<ID_Input>;
  subDivName: String;
  subDivCode: String;
  division: DivisionCreateOneInput;
}

export interface RegionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  regName?: Maybe<String>;
  regName_not?: Maybe<String>;
  regName_in?: Maybe<String[] | String>;
  regName_not_in?: Maybe<String[] | String>;
  regName_lt?: Maybe<String>;
  regName_lte?: Maybe<String>;
  regName_gt?: Maybe<String>;
  regName_gte?: Maybe<String>;
  regName_contains?: Maybe<String>;
  regName_not_contains?: Maybe<String>;
  regName_starts_with?: Maybe<String>;
  regName_not_starts_with?: Maybe<String>;
  regName_ends_with?: Maybe<String>;
  regName_not_ends_with?: Maybe<String>;
  regCode?: Maybe<String>;
  regCode_not?: Maybe<String>;
  regCode_in?: Maybe<String[] | String>;
  regCode_not_in?: Maybe<String[] | String>;
  regCode_lt?: Maybe<String>;
  regCode_lte?: Maybe<String>;
  regCode_gt?: Maybe<String>;
  regCode_gte?: Maybe<String>;
  regCode_contains?: Maybe<String>;
  regCode_not_contains?: Maybe<String>;
  regCode_starts_with?: Maybe<String>;
  regCode_not_starts_with?: Maybe<String>;
  regCode_ends_with?: Maybe<String>;
  regCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  OR?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  NOT?: Maybe<RegionWhereInput[] | RegionWhereInput>;
}

export interface SeriesUpdateManyMutationInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
}

export interface SubDivisionUpdateDataInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateOneRequiredInput>;
}

export type exanCenterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface exanCenterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<exanCenterWhereInput>;
  AND?: Maybe<
    exanCenterSubscriptionWhereInput[] | exanCenterSubscriptionWhereInput
  >;
  OR?: Maybe<
    exanCenterSubscriptionWhereInput[] | exanCenterSubscriptionWhereInput
  >;
  NOT?: Maybe<
    exanCenterSubscriptionWhereInput[] | exanCenterSubscriptionWhereInput
  >;
}

export interface SeriesUpdateInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
}

export interface TownSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TownWhereInput>;
  AND?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
  OR?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
  NOT?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
}

export interface exanCenterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  centerName?: Maybe<String>;
  centerName_not?: Maybe<String>;
  centerName_in?: Maybe<String[] | String>;
  centerName_not_in?: Maybe<String[] | String>;
  centerName_lt?: Maybe<String>;
  centerName_lte?: Maybe<String>;
  centerName_gt?: Maybe<String>;
  centerName_gte?: Maybe<String>;
  centerName_contains?: Maybe<String>;
  centerName_not_contains?: Maybe<String>;
  centerName_starts_with?: Maybe<String>;
  centerName_not_starts_with?: Maybe<String>;
  centerName_ends_with?: Maybe<String>;
  centerName_not_ends_with?: Maybe<String>;
  centerCode?: Maybe<String>;
  centerCode_not?: Maybe<String>;
  centerCode_in?: Maybe<String[] | String>;
  centerCode_not_in?: Maybe<String[] | String>;
  centerCode_lt?: Maybe<String>;
  centerCode_lte?: Maybe<String>;
  centerCode_gt?: Maybe<String>;
  centerCode_gte?: Maybe<String>;
  centerCode_contains?: Maybe<String>;
  centerCode_not_contains?: Maybe<String>;
  centerCode_starts_with?: Maybe<String>;
  centerCode_not_starts_with?: Maybe<String>;
  centerCode_ends_with?: Maybe<String>;
  centerCode_not_ends_with?: Maybe<String>;
  town?: Maybe<TownWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<exanCenterWhereInput[] | exanCenterWhereInput>;
  OR?: Maybe<exanCenterWhereInput[] | exanCenterWhereInput>;
  NOT?: Maybe<exanCenterWhereInput[] | exanCenterWhereInput>;
}

export interface PresenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  regName?: Maybe<Boolean>;
  regName_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
  OR?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
  NOT?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
}

export interface SeriesCreateInput {
  id?: Maybe<ID_Input>;
  seriesName: String;
  seriesCode: String;
}

export interface ExamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExamWhereInput>;
  AND?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
  OR?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
  NOT?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
}

export interface RegionUpdateManyMutationInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
}

export interface TownUpsertNestedInput {
  update: TownUpdateDataInput;
  create: TownCreateInput;
}

export interface RegionUpdateInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
}

export interface SeriesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seriesName?: Maybe<String>;
  seriesName_not?: Maybe<String>;
  seriesName_in?: Maybe<String[] | String>;
  seriesName_not_in?: Maybe<String[] | String>;
  seriesName_lt?: Maybe<String>;
  seriesName_lte?: Maybe<String>;
  seriesName_gt?: Maybe<String>;
  seriesName_gte?: Maybe<String>;
  seriesName_contains?: Maybe<String>;
  seriesName_not_contains?: Maybe<String>;
  seriesName_starts_with?: Maybe<String>;
  seriesName_not_starts_with?: Maybe<String>;
  seriesName_ends_with?: Maybe<String>;
  seriesName_not_ends_with?: Maybe<String>;
  seriesCode?: Maybe<String>;
  seriesCode_not?: Maybe<String>;
  seriesCode_in?: Maybe<String[] | String>;
  seriesCode_not_in?: Maybe<String[] | String>;
  seriesCode_lt?: Maybe<String>;
  seriesCode_lte?: Maybe<String>;
  seriesCode_gt?: Maybe<String>;
  seriesCode_gte?: Maybe<String>;
  seriesCode_contains?: Maybe<String>;
  seriesCode_not_contains?: Maybe<String>;
  seriesCode_starts_with?: Maybe<String>;
  seriesCode_not_starts_with?: Maybe<String>;
  seriesCode_ends_with?: Maybe<String>;
  seriesCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
  OR?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
  NOT?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
}

export interface PresenceUpdateManyMutationInput {
  regName?: Maybe<Boolean>;
}

export interface examSessionUpdateManyMutationInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
}

export interface examSessionCreateInput {
  id?: Maybe<ID_Input>;
  sessionName: String;
  sessionCode: String;
}

export type SubjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PresenceUpdateInput {
  regName?: Maybe<Boolean>;
}

export interface SubDivisionUpsertNestedInput {
  update: SubDivisionUpdateDataInput;
  create: SubDivisionCreateInput;
}

export interface RegionCreateOneInput {
  create?: Maybe<RegionCreateInput>;
  connect?: Maybe<RegionWhereUniqueInput>;
}

export interface examSessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<examSessionWhereInput>;
  AND?: Maybe<
    examSessionSubscriptionWhereInput[] | examSessionSubscriptionWhereInput
  >;
  OR?: Maybe<
    examSessionSubscriptionWhereInput[] | examSessionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    examSessionSubscriptionWhereInput[] | examSessionSubscriptionWhereInput
  >;
}

export interface RegionCreateInput {
  id?: Maybe<ID_Input>;
  regName: String;
  regCode: String;
}

export interface RegionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegionWhereInput>;
  AND?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  OR?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  NOT?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
}

export interface DivisionUpdateInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
  region?: Maybe<RegionUpdateOneRequiredInput>;
}

export type SeriesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RegionUpdateOneRequiredInput {
  create?: Maybe<RegionCreateInput>;
  update?: Maybe<RegionUpdateDataInput>;
  upsert?: Maybe<RegionUpsertNestedInput>;
  connect?: Maybe<RegionWhereUniqueInput>;
}

export interface examSessionUpdateInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
}

export interface RegionUpdateDataInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
}

export interface SubjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subjName?: Maybe<String>;
  subjName_not?: Maybe<String>;
  subjName_in?: Maybe<String[] | String>;
  subjName_not_in?: Maybe<String[] | String>;
  subjName_lt?: Maybe<String>;
  subjName_lte?: Maybe<String>;
  subjName_gt?: Maybe<String>;
  subjName_gte?: Maybe<String>;
  subjName_contains?: Maybe<String>;
  subjName_not_contains?: Maybe<String>;
  subjName_starts_with?: Maybe<String>;
  subjName_not_starts_with?: Maybe<String>;
  subjName_ends_with?: Maybe<String>;
  subjName_not_ends_with?: Maybe<String>;
  subjCode?: Maybe<String>;
  subjCode_not?: Maybe<String>;
  subjCode_in?: Maybe<String[] | String>;
  subjCode_not_in?: Maybe<String[] | String>;
  subjCode_lt?: Maybe<String>;
  subjCode_lte?: Maybe<String>;
  subjCode_gt?: Maybe<String>;
  subjCode_gte?: Maybe<String>;
  subjCode_contains?: Maybe<String>;
  subjCode_not_contains?: Maybe<String>;
  subjCode_starts_with?: Maybe<String>;
  subjCode_not_starts_with?: Maybe<String>;
  subjCode_ends_with?: Maybe<String>;
  subjCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  OR?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  NOT?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
}

export interface RegionUpsertNestedInput {
  update: RegionUpdateDataInput;
  create: RegionCreateInput;
}

export type PresenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExamCreateInput {
  id?: Maybe<ID_Input>;
  examName: String;
  examCode: String;
}

export interface ExamUpdateManyMutationInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
}

export interface PresenceCreateInput {
  id?: Maybe<ID_Input>;
  regName: Boolean;
}

export type ExamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DivisionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DivisionWhereInput>;
  AND?: Maybe<
    DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput
  >;
  OR?: Maybe<DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput>;
  NOT?: Maybe<
    DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput
  >;
}

export interface SubDivisionUpdateOneRequiredInput {
  create?: Maybe<SubDivisionCreateInput>;
  update?: Maybe<SubDivisionUpdateDataInput>;
  upsert?: Maybe<SubDivisionUpsertNestedInput>;
  connect?: Maybe<SubDivisionWhereUniqueInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface TownCreateOneInput {
  create?: Maybe<TownCreateInput>;
  connect?: Maybe<TownWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface exanCenterPreviousValues {
  id: ID_Output;
  centerName: String;
  centerCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface exanCenterPreviousValuesPromise
  extends Promise<exanCenterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface exanCenterPreviousValuesSubscription
  extends Promise<AsyncIterator<exanCenterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  centerName: () => Promise<AsyncIterator<String>>;
  centerCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateRegion {
  count: Int;
}

export interface AggregateRegionPromise
  extends Promise<AggregateRegion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegionSubscription
  extends Promise<AsyncIterator<AggregateRegion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateDivision {
  count: Int;
}

export interface AggregateDivisionPromise
  extends Promise<AggregateDivision>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDivisionSubscription
  extends Promise<AsyncIterator<AggregateDivision>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Series {
  id: ID_Output;
  seriesName: String;
  seriesCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeriesPromise extends Promise<Series>, Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeriesSubscription
  extends Promise<AsyncIterator<Series>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seriesName: () => Promise<AsyncIterator<String>>;
  seriesCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SeriesNullablePromise
  extends Promise<Series | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionEdge {
  node: Division;
  cursor: String;
}

export interface DivisionEdgePromise
  extends Promise<DivisionEdge>,
    Fragmentable {
  node: <T = DivisionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DivisionEdgeSubscription
  extends Promise<AsyncIterator<DivisionEdge>>,
    Fragmentable {
  node: <T = DivisionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface RegionEdge {
  node: Region;
  cursor: String;
}

export interface RegionEdgePromise extends Promise<RegionEdge>, Fragmentable {
  node: <T = RegionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegionEdgeSubscription
  extends Promise<AsyncIterator<RegionEdge>>,
    Fragmentable {
  node: <T = RegionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateexanCenter {
  count: Int;
}

export interface AggregateexanCenterPromise
  extends Promise<AggregateexanCenter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateexanCenterSubscription
  extends Promise<AsyncIterator<AggregateexanCenter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface exanCenterConnection {
  pageInfo: PageInfo;
  edges: exanCenterEdge[];
}

export interface exanCenterConnectionPromise
  extends Promise<exanCenterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<exanCenterEdge>>() => T;
  aggregate: <T = AggregateexanCenterPromise>() => T;
}

export interface exanCenterConnectionSubscription
  extends Promise<AsyncIterator<exanCenterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<exanCenterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateexanCenterSubscription>() => T;
}

export interface RegionConnection {
  pageInfo: PageInfo;
  edges: RegionEdge[];
}

export interface RegionConnectionPromise
  extends Promise<RegionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegionEdge>>() => T;
  aggregate: <T = AggregateRegionPromise>() => T;
}

export interface RegionConnectionSubscription
  extends Promise<AsyncIterator<RegionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegionSubscription>() => T;
}

export interface exanCenter {
  id: ID_Output;
  centerName: String;
  centerCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface exanCenterPromise extends Promise<exanCenter>, Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  town: <T = TownPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface exanCenterSubscription
  extends Promise<AsyncIterator<exanCenter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  centerName: () => Promise<AsyncIterator<String>>;
  centerCode: () => Promise<AsyncIterator<String>>;
  town: <T = TownSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface exanCenterNullablePromise
  extends Promise<exanCenter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  town: <T = TownPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface examSessionEdge {
  node: examSession;
  cursor: String;
}

export interface examSessionEdgePromise
  extends Promise<examSessionEdge>,
    Fragmentable {
  node: <T = examSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface examSessionEdgeSubscription
  extends Promise<AsyncIterator<examSessionEdge>>,
    Fragmentable {
  node: <T = examSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Division {
  id: ID_Output;
  divName: String;
  divCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DivisionPromise extends Promise<Division>, Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  region: <T = RegionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionSubscription
  extends Promise<AsyncIterator<Division>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  divName: () => Promise<AsyncIterator<String>>;
  divCode: () => Promise<AsyncIterator<String>>;
  region: <T = RegionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DivisionNullablePromise
  extends Promise<Division | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  region: <T = RegionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Region {
  id: ID_Output;
  regName: String;
  regCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegionPromise extends Promise<Region>, Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegionSubscription
  extends Promise<AsyncIterator<Region>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<String>>;
  regCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegionNullablePromise
  extends Promise<Region | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionSubscriptionPayload {
  mutation: MutationType;
  node: Division;
  updatedFields: String[];
  previousValues: DivisionPreviousValues;
}

export interface DivisionSubscriptionPayloadPromise
  extends Promise<DivisionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DivisionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DivisionPreviousValuesPromise>() => T;
}

export interface DivisionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DivisionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DivisionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DivisionPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DivisionPreviousValues {
  id: ID_Output;
  divName: String;
  divCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DivisionPreviousValuesPromise
  extends Promise<DivisionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionPreviousValuesSubscription
  extends Promise<AsyncIterator<DivisionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  divName: () => Promise<AsyncIterator<String>>;
  divCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregatePresence {
  count: Int;
}

export interface AggregatePresencePromise
  extends Promise<AggregatePresence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePresenceSubscription
  extends Promise<AsyncIterator<AggregatePresence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
}

export interface ExamSubscriptionPayload {
  mutation: MutationType;
  node: Exam;
  updatedFields: String[];
  previousValues: ExamPreviousValues;
}

export interface ExamSubscriptionPayloadPromise
  extends Promise<ExamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExamPreviousValuesPromise>() => T;
}

export interface ExamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExamPreviousValuesSubscription>() => T;
}

export interface TownEdge {
  node: Town;
  cursor: String;
}

export interface TownEdgePromise extends Promise<TownEdge>, Fragmentable {
  node: <T = TownPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TownEdgeSubscription
  extends Promise<AsyncIterator<TownEdge>>,
    Fragmentable {
  node: <T = TownSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExamPreviousValues {
  id: ID_Output;
  examName: String;
  examCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamPreviousValuesPromise
  extends Promise<ExamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamPreviousValuesSubscription
  extends Promise<AsyncIterator<ExamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  examName: () => Promise<AsyncIterator<String>>;
  examCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Town {
  id: ID_Output;
  townName: String;
  townCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TownPromise extends Promise<Town>, Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  subDiv: <T = SubDivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TownSubscription
  extends Promise<AsyncIterator<Town>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  townName: () => Promise<AsyncIterator<String>>;
  townCode: () => Promise<AsyncIterator<String>>;
  subDiv: <T = SubDivisionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TownNullablePromise
  extends Promise<Town | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  subDiv: <T = SubDivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PresenceEdge {
  node: Presence;
  cursor: String;
}

export interface PresenceEdgePromise
  extends Promise<PresenceEdge>,
    Fragmentable {
  node: <T = PresencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PresenceEdgeSubscription
  extends Promise<AsyncIterator<PresenceEdge>>,
    Fragmentable {
  node: <T = PresenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PresenceSubscriptionPayload {
  mutation: MutationType;
  node: Presence;
  updatedFields: String[];
  previousValues: PresencePreviousValues;
}

export interface PresenceSubscriptionPayloadPromise
  extends Promise<PresenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PresencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PresencePreviousValuesPromise>() => T;
}

export interface PresenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PresenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PresenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PresencePreviousValuesSubscription>() => T;
}

export interface Subject {
  id: ID_Output;
  subjName: String;
  subjCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjName: () => Promise<AsyncIterator<String>>;
  subjCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubjectNullablePromise
  extends Promise<Subject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PresencePreviousValues {
  id: ID_Output;
  regName: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PresencePreviousValuesPromise
  extends Promise<PresencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PresencePreviousValuesSubscription
  extends Promise<AsyncIterator<PresencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubDivisionEdge {
  node: SubDivision;
  cursor: String;
}

export interface SubDivisionEdgePromise
  extends Promise<SubDivisionEdge>,
    Fragmentable {
  node: <T = SubDivisionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubDivisionEdgeSubscription
  extends Promise<AsyncIterator<SubDivisionEdge>>,
    Fragmentable {
  node: <T = SubDivisionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PresenceConnection {
  pageInfo: PageInfo;
  edges: PresenceEdge[];
}

export interface PresenceConnectionPromise
  extends Promise<PresenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PresenceEdge>>() => T;
  aggregate: <T = AggregatePresencePromise>() => T;
}

export interface PresenceConnectionSubscription
  extends Promise<AsyncIterator<PresenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PresenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePresenceSubscription>() => T;
}

export interface examSessionPreviousValues {
  id: ID_Output;
  sessionName: String;
  sessionCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface examSessionPreviousValuesPromise
  extends Promise<examSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface examSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<examSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sessionName: () => Promise<AsyncIterator<String>>;
  sessionCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegionSubscriptionPayload {
  mutation: MutationType;
  node: Region;
  updatedFields: String[];
  previousValues: RegionPreviousValues;
}

export interface RegionSubscriptionPayloadPromise
  extends Promise<RegionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegionPreviousValuesPromise>() => T;
}

export interface RegionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegionPreviousValuesSubscription>() => T;
}

export interface AggregateSeries {
  count: Int;
}

export interface AggregateSeriesPromise
  extends Promise<AggregateSeries>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeriesSubscription
  extends Promise<AsyncIterator<AggregateSeries>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegionPreviousValues {
  id: ID_Output;
  regName: String;
  regCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegionPreviousValuesPromise
  extends Promise<RegionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegionPreviousValuesSubscription
  extends Promise<AsyncIterator<RegionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<String>>;
  regCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SeriesConnection {
  pageInfo: PageInfo;
  edges: SeriesEdge[];
}

export interface SeriesConnectionPromise
  extends Promise<SeriesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeriesEdge>>() => T;
  aggregate: <T = AggregateSeriesPromise>() => T;
}

export interface SeriesConnectionSubscription
  extends Promise<AsyncIterator<SeriesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeriesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeriesSubscription>() => T;
}

export interface examSessionSubscriptionPayload {
  mutation: MutationType;
  node: examSession;
  updatedFields: String[];
  previousValues: examSessionPreviousValues;
}

export interface examSessionSubscriptionPayloadPromise
  extends Promise<examSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = examSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = examSessionPreviousValuesPromise>() => T;
}

export interface examSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<examSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = examSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = examSessionPreviousValuesSubscription>() => T;
}

export interface exanCenterEdge {
  node: exanCenter;
  cursor: String;
}

export interface exanCenterEdgePromise
  extends Promise<exanCenterEdge>,
    Fragmentable {
  node: <T = exanCenterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface exanCenterEdgeSubscription
  extends Promise<AsyncIterator<exanCenterEdge>>,
    Fragmentable {
  node: <T = exanCenterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SeriesSubscriptionPayload {
  mutation: MutationType;
  node: Series;
  updatedFields: String[];
  previousValues: SeriesPreviousValues;
}

export interface SeriesSubscriptionPayloadPromise
  extends Promise<SeriesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeriesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeriesPreviousValuesPromise>() => T;
}

export interface SeriesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeriesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeriesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeriesPreviousValuesSubscription>() => T;
}

export interface AggregateexamSession {
  count: Int;
}

export interface AggregateexamSessionPromise
  extends Promise<AggregateexamSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateexamSessionSubscription
  extends Promise<AsyncIterator<AggregateexamSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SeriesPreviousValues {
  id: ID_Output;
  seriesName: String;
  seriesCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeriesPreviousValuesPromise
  extends Promise<SeriesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeriesPreviousValuesSubscription
  extends Promise<AsyncIterator<SeriesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seriesName: () => Promise<AsyncIterator<String>>;
  seriesCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface examSession {
  id: ID_Output;
  sessionName: String;
  sessionCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface examSessionPromise extends Promise<examSession>, Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface examSessionSubscription
  extends Promise<AsyncIterator<examSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sessionName: () => Promise<AsyncIterator<String>>;
  sessionCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface examSessionNullablePromise
  extends Promise<examSession | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Presence {
  id: ID_Output;
  regName: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PresencePromise extends Promise<Presence>, Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PresenceSubscription
  extends Promise<AsyncIterator<Presence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PresenceNullablePromise
  extends Promise<Presence | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Exam {
  id: ID_Output;
  examName: String;
  examCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamPromise extends Promise<Exam>, Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamSubscription
  extends Promise<AsyncIterator<Exam>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  examName: () => Promise<AsyncIterator<String>>;
  examCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamNullablePromise
  extends Promise<Exam | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubDivisionSubscriptionPayload {
  mutation: MutationType;
  node: SubDivision;
  updatedFields: String[];
  previousValues: SubDivisionPreviousValues;
}

export interface SubDivisionSubscriptionPayloadPromise
  extends Promise<SubDivisionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubDivisionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubDivisionPreviousValuesPromise>() => T;
}

export interface SubDivisionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubDivisionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubDivisionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubDivisionPreviousValuesSubscription>() => T;
}

export interface TownConnection {
  pageInfo: PageInfo;
  edges: TownEdge[];
}

export interface TownConnectionPromise
  extends Promise<TownConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TownEdge>>() => T;
  aggregate: <T = AggregateTownPromise>() => T;
}

export interface TownConnectionSubscription
  extends Promise<AsyncIterator<TownConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TownEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTownSubscription>() => T;
}

export interface SubDivisionPreviousValues {
  id: ID_Output;
  subDivName: String;
  subDivCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubDivisionPreviousValuesPromise
  extends Promise<SubDivisionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubDivisionPreviousValuesSubscription
  extends Promise<AsyncIterator<SubDivisionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subDivName: () => Promise<AsyncIterator<String>>;
  subDivCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface AggregateExam {
  count: Int;
}

export interface AggregateExamPromise
  extends Promise<AggregateExam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExamSubscription
  extends Promise<AsyncIterator<AggregateExam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubDivisionConnection {
  pageInfo: PageInfo;
  edges: SubDivisionEdge[];
}

export interface SubDivisionConnectionPromise
  extends Promise<SubDivisionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubDivisionEdge>>() => T;
  aggregate: <T = AggregateSubDivisionPromise>() => T;
}

export interface SubDivisionConnectionSubscription
  extends Promise<AsyncIterator<SubDivisionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubDivisionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubDivisionSubscription>() => T;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface SeriesEdge {
  node: Series;
  cursor: String;
}

export interface SeriesEdgePromise extends Promise<SeriesEdge>, Fragmentable {
  node: <T = SeriesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeriesEdgeSubscription
  extends Promise<AsyncIterator<SeriesEdge>>,
    Fragmentable {
  node: <T = SeriesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubjectPreviousValues {
  id: ID_Output;
  subjName: String;
  subjCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjName: () => Promise<AsyncIterator<String>>;
  subjCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface exanCenterSubscriptionPayload {
  mutation: MutationType;
  node: exanCenter;
  updatedFields: String[];
  previousValues: exanCenterPreviousValues;
}

export interface exanCenterSubscriptionPayloadPromise
  extends Promise<exanCenterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = exanCenterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = exanCenterPreviousValuesPromise>() => T;
}

export interface exanCenterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<exanCenterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = exanCenterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = exanCenterPreviousValuesSubscription>() => T;
}

export interface ExamEdge {
  node: Exam;
  cursor: String;
}

export interface ExamEdgePromise extends Promise<ExamEdge>, Fragmentable {
  node: <T = ExamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExamEdgeSubscription
  extends Promise<AsyncIterator<ExamEdge>>,
    Fragmentable {
  node: <T = ExamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TownSubscriptionPayload {
  mutation: MutationType;
  node: Town;
  updatedFields: String[];
  previousValues: TownPreviousValues;
}

export interface TownSubscriptionPayloadPromise
  extends Promise<TownSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TownPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TownPreviousValuesPromise>() => T;
}

export interface TownSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TownSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TownSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TownPreviousValuesSubscription>() => T;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubDivision {
  id: ID_Output;
  subDivName: String;
  subDivCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubDivisionPromise extends Promise<SubDivision>, Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  division: <T = DivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubDivisionSubscription
  extends Promise<AsyncIterator<SubDivision>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subDivName: () => Promise<AsyncIterator<String>>;
  subDivCode: () => Promise<AsyncIterator<String>>;
  division: <T = DivisionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubDivisionNullablePromise
  extends Promise<SubDivision | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  division: <T = DivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ExamConnection {
  pageInfo: PageInfo;
  edges: ExamEdge[];
}

export interface ExamConnectionPromise
  extends Promise<ExamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExamEdge>>() => T;
  aggregate: <T = AggregateExamPromise>() => T;
}

export interface ExamConnectionSubscription
  extends Promise<AsyncIterator<ExamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExamSubscription>() => T;
}

export interface TownPreviousValues {
  id: ID_Output;
  townName: String;
  townCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TownPreviousValuesPromise
  extends Promise<TownPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TownPreviousValuesSubscription
  extends Promise<AsyncIterator<TownPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  townName: () => Promise<AsyncIterator<String>>;
  townCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DivisionConnection {
  pageInfo: PageInfo;
  edges: DivisionEdge[];
}

export interface DivisionConnectionPromise
  extends Promise<DivisionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DivisionEdge>>() => T;
  aggregate: <T = AggregateDivisionPromise>() => T;
}

export interface DivisionConnectionSubscription
  extends Promise<AsyncIterator<DivisionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DivisionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDivisionSubscription>() => T;
}

export interface AggregateSubDivision {
  count: Int;
}

export interface AggregateSubDivisionPromise
  extends Promise<AggregateSubDivision>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubDivisionSubscription
  extends Promise<AsyncIterator<AggregateSubDivision>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTown {
  count: Int;
}

export interface AggregateTownPromise
  extends Promise<AggregateTown>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTownSubscription
  extends Promise<AsyncIterator<AggregateTown>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface examSessionConnection {
  pageInfo: PageInfo;
  edges: examSessionEdge[];
}

export interface examSessionConnectionPromise
  extends Promise<examSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<examSessionEdge>>() => T;
  aggregate: <T = AggregateexamSessionPromise>() => T;
}

export interface examSessionConnectionSubscription
  extends Promise<AsyncIterator<examSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<examSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateexamSessionSubscription>() => T;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Region",
    embedded: false
  },
  {
    name: "Division",
    embedded: false
  },
  {
    name: "SubDivision",
    embedded: false
  },
  {
    name: "Town",
    embedded: false
  },
  {
    name: "exanCenter",
    embedded: false
  },
  {
    name: "Series",
    embedded: false
  },
  {
    name: "Exam",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "Presence",
    embedded: false
  },
  {
    name: "examSession",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
